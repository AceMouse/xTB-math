\section{Theory}
\subsection{GFN2-xTB}
GFN2-xTB is a part of the GFNn-xTB (Geometry, Frequency, Non covalent, eXtended Tight Binding) family of semi-empirical methods for computational chemistry. 
The method gives good approximations for molecular geometries, vibrational frequencies, and non-covalent interaction energies but also does well on a variety other properties. 
Over all it strives to hit a balance between being accurate, close to the physics, general over a wide range of elements and not too computationally expensive.
This is achieved by approximating a true quantum mechanical simulation, using carefully chosen approximations and parameters. 
In contrast to forcefield methods that often operate on the level of atoms or even functional groups interacting the method is still treating the calculations at the level of individual shells in many places. 
GFN2-xTB uses A Self-Consistent Charges approach i.e. it makes an initial guess at a density matrix and an energy which it then iteratively refines until both have converged. 

\begin{figure}[H]
\begin{minted}{python}
def get_GFN2_energy(atoms: list[int], positions : list[list[float]]) -> float:
    density = P(atoms)
    overlap = S(atoms, positions)
    dipol_dipol = D(atoms, positions, overlap)
    charge_quadrupol = Q(atoms, positions, overlap, dipol_dipol)
    initial_hamiltonian = H0(atoms, positions)
    huckel_theory_matrix = H_EHT(atoms, positions, overlap, initial_hamiltonian)
    charges = mulliken_population_analysis(density,atoms)
    E_repulsion = repulsion(atoms, positions)
    E_dispersion = D4Prime(charges, atoms, positions)
    E_huckel = Huckel(density, extended_huckel_theory_matrix)
    E_anisotropic = AES(charges, overlap, dipol_dipol, charge_quadrupol, positions)
    E_isotropic = IES(charges, positions)
    E = E_repulsion + E_dispersion + E_huckel + E_anisotropic + E_isotropic
    # ...
    while not (energy_converged and densities_converged):
        eigen_values = diagonalize(hamiltonian, overlap) # HC=SCe 
        new_density = compute_density_matrix_from_fermi(eigen_values,...)
        # ... update everything with new density
        energy_converged = (E-E_new)**2 < tolerance
        densities_converged = error_squared(density,new_density) < tolerance
        E = E_new
        density = new_density
\end{minted}
\caption{Python like code illustrating the main loop of a GFN2-xTB implementation.
Line 2-14 computes the energy in a non SCC manner, line 15-23 iteratively improves the energy using SCC.
}
\end{figure}
Let us define a small helper function to decrease the amount of indentation in the later code examples. 
\begin{figure}[H]
\begin{minted}{python}
def get_orbitals(atoms: list[int]) -> list[tuple[int]]:
    orbitals = []
    for atom_idx,atom in enumerate(atoms):
        for subshell in range(number_of_subshells[atom]):
            l = angular_momentum_of_subshell[atom][subshell] 
            for orbital in range(l*2+1):
                orbitals.append((atom_idx,atom,subshell,orbital))
    return orbitals
\end{minted}
\caption{Python like code for generating a convenient list of orbitals to iterate though. }
\end{figure}
And a helper function to create a square matrix.
\begin{figure}[H]
\begin{minted}{python}
def get_square_matrix(n: int) -> list[list[float]]:
    matrix = []
    for _ in range(n):
        row = []
        for _ in range(n):
            row.append(0.0)
        matrix.append(row)
    return matrix
\end{minted}
\caption{Python like code for generating a square matrix.}
\end{figure}


The initial density matrix guess is formulated as a superposition of neutral atomic reference densities $P_0 = \sum_{A}P_{A_0}$. This means that we let $P_0$ be a diagonal matrix that is $n$ by $n$ where $n$ is the total number of orbitals across the whole molecule. The values on the diagonal are the fractional number of electrons in the orbitals, the fractional occupations. The shells are filled from the nucleus and outwards. 
\begin{figure}[H]
\begin{minted}{python}
def density_initial_guess(atoms: list[int]) -> list[list[float]]:
    orbitals = get_orbitals(atoms)
    occs = get_square_matrix(len(orbitals))
    for idx,(_,atom,subshell,orbital) in enumerate(orbitals):
        l = angular_momentum_of_subshell[atom][subshell] 
        orbitals_in_subshell = l*2+1 
        electrons_in_subshell = reference_occupations[atom][subshell]
        electrons_per_orbital = electrons_in_subshell/orbitals_in_subshell
        occs[idx][idx] = electrons_per_orbital
    return occs
\end{minted}
\caption{Python like code illustrating computation of $P_0$}
\end{figure}
For fullerenes the guess is simply all ones on the diagonal as number\_of\_subshells[C] = 2, angular\_momentum\_of\_subshell[C] = [0,1,0] and reference\_occupations[C] = [1.0,3.0,0.0]. Thus occ will be a repeating series of [$\frac{1.0}{1},\frac{3.0}{3},\frac{3.0}{3},\frac{3.0}{3}$].
We also need the overlap matrix, $S$, which is computed in the following way.
\begin{equation}
S_{\nu\mu} = \braket{\nu|\mu}\quad\quad\quad\quad\forall \nu \in l \in A,\mu \in l' \in B
\end{equation}
\begin{figure}[H]
\begin{minted}{python}
def overlap(atoms: list[int]) -> list[list[float]]:
    orbitals = get_orbitals(atoms)
    S = get_square_matrix(len(orbitals))
    for idx_A, (_,atom_A,subshell_A,orbital_A) in enumerate(orbitals):
        for idx_B, (_,atom_B,subshell_B,orbital_B) in enumerate(orbitals):
            if idx_A == idx_B:
                S[idx_A][idx_B] = 1
            else:
                S[idx_A][idx_B] = compute_integral(...)
    return S
def compute_integral(atom_A:int, atom_B:int, shell_A:int, shell_B:int, orbital_A:int, orbital_B:int)-> float:
    #...
\end{minted}
\caption{Python like code illustrating construction of $S$}
\end{figure}
NOTE(Asmus) Explain D and Q as well


The huckel matrix is calculated using extended huckel theory. This is the calculation.
\begin{gather}
    H_{\nu\nu} = H_A^l - H_{CN_A}CN_A' \quad\quad\quad\quad\forall \nu \in l \in A\\
    \begin{split}
        CN_A' = &\sum_{B\neq A}\left(1+e^{-10\left(\frac{4\left(R_{A,cov}+R_{B,cov}\right)}{3R_{AB}}-1\right)}\right)^{-1}\left(1+e^{-20\left(\frac{4\left(R_{A,cov}+R_{B,cov}+2\right)}{3R_{AB}}-1\right)}\right)^{-1}
    \end{split}
\end{gather}
\begin{figure}[H]
\begin{minted}{python}
def huckel_matrix(atoms: list[int], positions: list[list[float]], overlap: list[list[float]]) -> list[list[float]]:
    orbitals = get_orbitals(atoms)
    H_EHT = get_square_matrix(len(orbitals))
    CN = get_coordination_numbers(atoms,positions)
    for orbital_idx, (atom_idx,atom,subshell,orbital) in enumerate(orbitals):
        CN_A = CN[atom_idx]
        H_A = self_energy[atom][subshell] # constant
        H_CN_A = GFN2_H_CN_A[atom][subshell] # constant
        H_EHT[orbital_idx][orbital_idx] = H_A - H_CN_A*CN_A

    for idx_A,(atom_A_idx,atom_A,subshell_A,_) in enumerate(orbitals):
        l_A = angular_momentum_of_subshell[atom_A][subshell_A]
        EN_A = electro_negativity[atom_A]
        R_A = positions[atom_A_idx]
        Rcov_A = covalent_radii[atom_A]
        k_poly_A = k_poly[atom_A][l_A]
        for idx_B,(atom_B_idx,atom_B,subshell_B,_) in enumerate(orbitals):
            if idx_A == idx_B:
                continue
            l_B = angular_momentum_of_subshell[atom_B][subshell_B]
            EN_B = electro_negativity[atom_B]
            R_B = positions[atom_B_idx]
            Rcov_B = covalent_radii[atom_B]
            k_poly_B = k_poly[atom_B][l_B]
            K_ll = GFN2_K_AB[l_A][l_B]
            delta_EN_squared = (EN_A-EN_B)**2
            k_EN = 0.02
            X = 1+k_EN*delta_EN_squared
            R_AB = euclidean_distance(R_A,R_B) 
            Rcov_AB = Rcov_A + Rcov_B 
            PI = (1+k_poly_A*sqrt(R_AB/Rcov_AB)) * (1+k_poly_B*sqrt(R_AB/Rcov_AB))
            slater_exp_A = slater_exponent[atom_A][l_A]
            slater_exp_B = slater_exponent[atom_B][l_B]
            Y = sqrt((2*sqrt(slater_exp_A*slater_exp_B)) / (slater_exp_A+slater_exp_B))
            H_nn = H_EHT[idx_A][idx_A]
            H_mm = H_EHT[idx_B][idx_B]
            S_nm = overlap[idx_B][idx_B]
            H_EHT[idx_A][idx_B] = k_ll*(1/2)*(H_nn+H_mm)*S_nm*Y*X*PI
    return H_EHT
\end{minted}
\caption{Python like code illustrating construction of $H_{KK}$}
\end{figure}


