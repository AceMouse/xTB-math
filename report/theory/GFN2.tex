\chapter{Introduction to GFN2-xTB}\label{sec:gfn2}
In this section we will go over the GFN2-xTB energy terms put forth in the related papers\cite{grimme2017,bannwarth2019,bannwarth2021}.
GFN2-xTB is a part of the GFNn-xTB (Geometry, Frequency, Non covalent, eXtended Tight Binding) family of semi-empirical methods for computational chemistry. 

The method gives good approximations for molecular geometries, vibrational frequencies, and non-covalent interaction energies and also does well on a variety other properties. 
Overall it strives to hit a balance between being accurate, close to the physics, general over a wide range of elements and not too computationally expensive.

This is achieved by approximating a true quantum mechanical simulation, using carefully chosen approximations and parameters. 
In contrast to forcefield methods that often operate on the level of atoms or even functional groups interacting, GFN2-xTB still treats the calculations at the level of individual orbitals in many places. 

GFN2-xTB uses a Self-Consistent Charges (SCC) approach i.e. it makes an initial guess at a density matrix and an energy which it then iteratively refines until both have converged. We are mostly interested in the final energy. 

\section{Energy Terms}
The terms in GFN2-xTB that determine the energy are as follows
\begin{equation}
E =\E{rep}+\E{disp}^{D4'}+\E{EHT}+\E{\gamma}+\E{AES}+\E{AXC}+\E{\Gamma} + G_{Fermi}
\end{equation}

We then have to also factor in the SCC. 
Let us consider the following code sketch in figure \ref{lst:total_energy} which we will fill out in this chapter. The chapter will go over each term and add code snippets illustrating the mathematics in a more concrete way. 
\begin{figure}[H]
\begin{minted}{python}
def get_GFN2_energy(atoms: list[int], positions : list[list[float]], free_electrons : int, charge : int) -> float:
    density = density_initial_guess(atoms)
    overlap, dipol_dipol, charge_quadrupol = overlap_dipol_quadrupol(atoms, positions)
    huckel_matrix = huckel_matrix(atoms, positions, overlap)
    charges = mulliken_population_analysis(density, atoms)
    E_repulsion = repulsion_energy(atoms, positions)
    E_dispersion = D4Prime_energy(charges, atoms, positions)
    E_huckel = huckel_energy(density, extended_huckel_theory_matrix)
    E_anisotropic = anisotropic_energy(charges, overlap, dipol_dipol, charge_quadrupol, positions)
    E_isotropic = isotropic_energy(charges, positions)
    initial_hamiltonian = fock_matrix(...)
    eigen_values = diagonalise(initial_hamiltonian, overlap) # HC=SCe 
    E_fermi = fermi_energy(eigen_values, atoms, free_electrons, charge)
    E = E_repulsion + E_dispersion + E_huckel + E_anisotropic + E_isotropic + E_Fermi
    while not (energy_converged and densities_converged):
        # change densities along the gradients and 
        # update everything using the new density
        # ...
        energy_converged = (E-E_new)**2 < tolerance
        densities_converged = error_squared(density, new_density) < tolerance
        E = E_new
        density = new_density
\end{minted}
\caption{Python code illustrating the main loop of a GFN2-xTB implementation.
Line 2-14 computes the energy in a non SCC manner, line 15-22 iteratively improves the energy using SCC.
Another way to describe this is that the zeroth iteration of SCC happens outside the loop as there is some setup required. 
}
    \label{lst:total_energy}
\end{figure}
Let us define a small helper function to decrease the amount of indentation in the later code examples. This will allow us to easily loop over the orbitals and know which atom and shell each belongs to. 
\begin{figure}[H]
\begin{minted}{python}
def get_orbitals(atoms: list[int]) -> list[tuple[int]]:
    orbitals = []
    for atom_idx,atom in enumerate(atoms):
        for subshell in range(number_of_subshells[atom]):
            l = angular_momentum_of_subshell[atom][subshell] 
            for orbital in range(l*2+1):
                orbitals.append((atom_idx,atom,subshell,orbital))
    return orbitals
\end{minted}
\caption{Python code for generating a convenient list of orbitals to iterate though. }
\end{figure}

And some functions used when we want to signal to the reader that the python list we just created will stay a fixed size. Additionally we get to contain the python list comprehension syntax here. 

\begin{figure}[H]
\begin{minted}{python}
def vector(n: int) -> list[float]:
    return [0.0 for _ in range(n)]

def square_matrix(n: int) -> list[list[float]]:
    return [[0.0 for _ in range(n)] for _ in range(n)]

def square_matrix_of_vectors(n: int, v:int) -> list[list[list[float]]]:
    return [[[0.0 for _ in range(v)] for _ in range(n)] for _ in range(n)]
\end{minted}
    \caption{Python code for creating a $n$ long vector, $n\times n$ matrix and $n\times n \times v$ tensor.}
\end{figure}

For many of the upcoming calculations we will need to work with the distance between atoms. We will say the position of atom A is:
\begin{equation}
\pmb{R}_A=
    \begin{pmatrix}
    {R_A}_x\\
    {R_A}_y\\{R_A}_z
    \end{pmatrix}
\end{equation}
Where $R_u$ with $u\in x,y,z$ is the coresponding component in $\pmb{R}$.

Then we note the euclidean distance as follows:
\begin{align}
    \pmb{R}_{AB} &= \pmb{R}_A-\pmb{R}_B=
    \begin{pmatrix}
    {R_A}_x-{R_B}_x\\
    {R_A}_y-{R_B}_y\\
    {R_A}_z-{R_B}_z
    \end{pmatrix}
\\
    R_{AB} &= \sqrt{({R_{AB}}_x)^2+({R_{AB}}_y)^2+({R_{AB}}_x)^2}
\end{align}
Now let us dig into the calculations. 
\section{Constructing the Initial Density Matrix}
Many of the terms use the density matrix as part of their calculation and it is central to the SCC method. In the GFN2 paper the initial density matrix guess is formulated as a superposition of neutral atomic reference densities $P_0 = \sum_{A}P_{A_0}$. In simpler terms this means that we let $P_0$ be a diagonal matrix that is $n$ by $n$ where $n$ is the total number of orbitals across the whole molecule. The values on the diagonal are the fractional number of electrons in the orbitals, the fractional occupations. They are reference densities so we get them in a table we can index into per subshell, thus we just have to divide the electrons evenly between the orbitals in the subshell. The number of orbitals in a subshell is $2l+1$ where l is the quantum number corresponding to the angular momentum of the subshell.
\begin{figure}[H]
\begin{minted}{python}
def density_initial_guess(atoms: list[int]) -> list[list[float]]:
    orbitals = get_orbitals(atoms)
    fractional_occupations = square_matrix(len(orbitals))
    for orbital_idx,(_,atom,subshell,_) in enumerate(orbitals):
        l = angular_momentum_of_subshell[atom][subshell] 
        orbitals_in_subshell = l*2+1 
        electrons_in_subshell = reference_occupations[atom][subshell]
        electrons_per_orbital = electrons_in_subshell/orbitals_in_subshell
        fractional_occupations[orbital_idx][orbital_idx] = electrons_per_orbital
    return fractional_occupations
\end{minted}
\caption{Python code for computation of the initial density matrix $P_0$}
    \label{lst:orbitals}
\end{figure}
For fullerenes the guess is simply all ones on the diagonal as \verb|number_of_subshells[C] = 2|, \verb|angular_momentum_of_subshell[C] = [0,1,0]| and \verb|reference_occupations[C] = [1.0,3.0,0.0]|.
Here \verb|C=5| is the index for carbon. 
Thus \verb|fractional_occupations| will contain a repeating series of $\frac{1}{0\cdot2+1},\frac{3}{1\cdot2+1},\frac{3}{1\cdot2+1},\frac{3}{1\cdot2+1}$ on the diagonal.

\section{Constructing the Overlap, Dipol and Quadrupol Tensors}

We need the overlap matrix, $S$, for several of the terms. 
The related dipol and quadrupol tensors denoted $D$ and $Q$ are also needed and due to their very similar construction we will go over the implementation and mathematics in one fell swoop. 
An element in each tensor is computed in the following way.
\begin{align}
    S_{\nu\mu} &= \braket{\psi_\nu|\psi_\mu} &\forall \nu \in l \in A,\quad\forall\mu \in l' \in B, \\
    D_{\nu\mu}^{u} &= \braket{\psi_\nu|(r_u-{R_P}_u)|\psi_\mu}  &\forall  u\in x,y,z\\
    Q_{\nu\mu}^{uv} &= \braket{\psi_\nu|(r_u-{R_P}_u)(r_v-{R_P}_v)|\psi_\mu} &\forall  v\in x,y,z
\end{align}
These are integrals between two Slater type orbitals (STOs) over the positions $r$. When we write $l \in A$ we mean to iterate though the subshells in every element A and take their angular momentum. $\nu\in l$ means that we iterate though the $2l+1$ orbitals in the subshell with quantum number $m\in\{-l,..,0,..,l\}$. See figure \ref{lst:orbitals} for a code example. ${R_P}$ is the $x,y,z$ position of the product of the orbitals, we will define this later.

For $D$ there are 3 unique values, corresponding to the 3 dimensions, to compute for each pair of orbitals which we will pack into an array. 
Since $(r_u-{R_P}_u)(r_v-{R_P}_v)=(r_v-{R_P}_v)(r_u-{R_P}_u)$ there are 6, rather than 9, unique combinations of dimensions to compute for each element in the $Q$ tensor which we will also pack into an array.
For the sake of clarity we will define the indices corresponding to the combinations of directions, these are however arbitrary and only used for array indexing.  
\begin{figure}[H]
\begin{minted}{python}
    x = 0
    y = 1
    z = 2
    xx = 0
    yy = 1
    zz = 2
    xy = 3
    xz = 4
    yz = 5
\end{minted}
\caption{Constants for the combinations of directions.}
\end{figure}
\begin{figure}[H]
\begin{minted}{python}
def overlap_dipol_quadrupol(atoms: list[int], positions: list[list[float]])-> tuple[list[list[float]],list[list[list[float]]],list[list[list[float]]]]:
    orbitals = get_orbitals(atoms)
    S = square_matrix(len(orbitals))
    D = square_matrix_of_vectors(len(orbitals),3)
    Q = square_matrix_of_vectors(len(orbitals),6)
    for idx_A, (atom_idx_A,atom_A,subshell_A,orbital_A) in enumerate(orbitals):
        for idx_B, (atom_idx_B,atom_B,subshell_B,orbital_B) in enumerate(orbitals):
            R_A = positions[atom_idx_A]
            R_B = positions[atom_idx_B]
            l_A = angular_momentum_of_subshell[atom_A][subshell_A]
            l_B = angular_momentum_of_subshell[atom_B][subshell_B]
            s,d,q = compute_STO_integrals(atom_A, subshell_A, orbital_A, R_A, l_A, atom_B, subshell_B, orbital_B, R_B, l_B)
            S[idx_A][idx_B] = s
            for dir in [x,y,z]:
                D[idx_A][idx_B][dir] = d[dir]
            for dir in [xx,yy,zz,xy,xz,yz]:
                Q[idx_A][idx_B][dir] = q[dir]
    return S,D,Q
\end{minted}
\caption{Python snippet illustrating construction of the overlap, dipol and quadrupol tensors; $S,D$ and $Q$.}
\end{figure}

To compute the integrals we need to remember that in GFN2-xTB an STO is approximated as a linear combination of gaussian type orbitals:
\begin{equation}
    \begin{split}
        \ket{\psi_\nu} =&\psi(\zeta_{A,l},\pmb r-\pmb R_A) \\
        = &N_{STO,l}|\pmb r-\pmb R_A|^{n-1}e^{-\zeta_{A,l}|\pmb r-\pmb R_A|}Y_l^m(\pmb r-\pmb R_A)\\
        \approx &\sum_i^{N_{A,l}}c_{i,\nu}N_{GTO,l}(r_x-{R_A}_x)^{l_x}(r_y-{R_A}_y)^{l_y}(r_z-{R_A}_z)^{l_z}e^{-\alpha_{i,\nu}|\pmb r-\pmb R_A|^2}\\
        =& \sum_i^{N_{A,l}}c_{i,\nu}\phi(\alpha_{i,\nu},\pmb r-\pmb R_A)\\
        =& \sum_i^{N_{A,l}}c_{i,\nu}\ket{\phi_i}
    \end{split}
\end{equation}
Where $N_{A,l}$ is an element and shell dependant constant, it is the number of GTOs used to approximate the STO. $\zeta$ and $\alpha$ are the slater and gaussian exponents. The contraction coefficient $c$ is a fitted value, it is fitted with the assumption that $\zeta=1$ and to get the value we will actually be using, we need to scale the fitted value by $\zeta^2$. $N_{STO,l}$ and $N_{GTO,l}$ are normalisation terms. 
We will refer to the terms $(r_u-{R_A}_u)^{l_u}\quad\forall{u\in x,y,z}$ as polynomial prefactors. 
The approximation in terms of GTOs means we can express our overlap in terms of GTO integrals instead:
\begin{align}
    S_{\nu\mu} &=\sum_i^{N_{A,l}}\sum_j^{N_{B,l'}}c_{i,\nu}c_{j,\mu} \braket{\phi_i|\phi_j}\\
    D_{\nu\mu}^u &=\sum_i^{N_{A,l}}\sum_j^{N_{B,l'}}c_{i,\nu}c_{j,\mu} \braket{\phi_i|(r_u-{R_P}_u)|\phi_j}\\
    Q_{\nu\mu}^{uv} &=\sum_i^{N_{A,l}}\sum_j^{N_{B,l'}}c_{i,\nu}c_{j,\mu} \braket{\phi_i|(r_u-{R_P}_u)(r_v-{R_P}_v)|\phi_j}
\end{align}
\begin{figure}[H]
\begin{minted}{python}
def compute_STO_integrals(atom_A: int, subshell_A: int, orbital_A: int, R_A: float, l_A: int, atom_B: int, subshell_B: int, orbital_B: int, R_B: float, l_B: int) -> tuple[float,list[float],list[float]]:
    number_of_gaussians_A = number_of_gaussians[atom_A][subshell_A]
    number_of_gaussians_B = number_of_gaussians[atom_B][subshell_B]
    slater_exponent_A = slater_exponents[atom_A][subshell_A]
    slater_exponent_B = slater_exponents[atom_B][subshell_B]
    overlap = 0
    dipol = vector(3)
    quadrupol = vector(6)
    for gaussian_i in range(number_of_gaussians_A):
        for gaussian_j in range(number_of_gaussians_B):
            exponent_i = normalised_gaussian_exponent(atom_A, subshell_A, gaussian_i, slater_exponent_A)
            exponent_j = normalised_gaussian_exponent(atom_B, subshell_B, gaussian_j, slater_exponent_B)
            contraction_i = normalised_contraction_coeficient(atom_A, subshell_A, gaussian_i, exponent_i)
            contraction_j = normalised_contraction_coeficient(atom_B, subshell_B, gaussian_j, exponent_j)
            distance_between_A_B = euclidean_distance(R_A, R_B)
            s,d,q = compute_GTO_integrals(R_A, l_A, orbital_A, R_B, l_B, orbital_B, exponent_i, exponent_j, distance_between_A_B)
            overlap += contraction_i*contraction_j*s
            for dir in [x,y,z]:
                dipol[dir] += contraction_i*contraction_j*d[dir]
            for dir in [xx,yy,zz,xy,xz,yz]:
                quadrupol[dir] += contraction_i*contraction_j*q[dir]
    return overlap,dipol,quadrupol
\end{minted}
    \caption{Python snippet illustrating construction of the STO integrals $\braket{\psi_\nu|\cdots|\psi_\mu}$.}
\end{figure}

The gaussian normalisation term\cite[eq. 5.55]{daudel} is:
\begin{align}
    1&=N_{GTO,l}^2(2\alpha_{i,\nu})^{-(l+3/2)}\frac{({l_A}_x-1)!!({l}_y-1)!!({l}_z-1)!!}{2^{l/2}}\pi^{3/2}\\
    N_{GTO,l}^2&=\left((2\alpha_{i,\nu})^{-(l+3/2)}\frac{({l}_x-1)!!({l}_y-1)!!({l}_z-1)!!}{2^{l/2}}\pi^{3/2}\right)^{-1}\\
    N_{GTO,l}&=\left((2\alpha_{i,\nu})^{-(l+3/2)}\frac{({l}_x-1)!!({l}_y-1)!!({l}_z-1)!!}{2^{l/2}}\pi^{3/2}\right)^{-1/2}
\end{align}
Here $l_u$ for $u\in x,y,z$ is the angular momentum in that dimension for the orbital, summing over $u$ gives $l$.
Which for fullerenes would be 
\begin{align}
    N_{GTO,l}&=\left((2\alpha_{i,\nu})^{-(l+3/2)}2^{-l/2}\pi^{3/2}\right)^{-1/2}
\end{align}

We only need the GTO ones and can compute them in the following way:
\begin{figure}[H]
\begin{minted}{python}
def normalised_gaussian_exponent(atom: int, subshell: int, gaussian: int, slater_exponent: float) -> float:
    normalisation_factor = slater_exponent**2
    return gaussian_exponents[atom][subshell][gaussian]*normalisation_factor

def normalised_contraction_coefficient(atom: int, subshell: int, gaussian: int, gaussian_exponent: float) -> float:
    l = angular_momentum_of_subshell[atom][subshell]
    l_x = angular_momentum_of_subshell_in_dimension[atom][subshell][x]
    l_y = angular_momentum_of_subshell_in_dimension[atom][subshell][y]
    l_z = angular_momentum_of_subshell_in_dimension[atom][subshell][z]
    df_x = double_factorial(l_x-1)
    df_y = double_factorial(l_y-1)
    df_z = double_factorial(l_z-1)
    normalization_factor = (2*alpha)**(-(l+3/2)) * ((df_x*df_y*df_z)/(2**(l/2))) * pi**(3/2)
    return contraction_coeficients[atom][shell][gaussian]*normalisation_factor

def double_factorial(n: int) -> int:
    if n <= 1:
        return 1
    return n*double_factorial(n-2)
\end{minted}
    \caption{Python snippet illustrating normalisation of the gaussian exponents and contraction coefficients.}
\end{figure}

As the GTOs in the integral are real valued functions we can drop the conjugation when we write them out.
We see that we have to compute the products of GTOs. The product of two Gaussians is a new Gaussian centred at a point between the two, $R_P$, which we will finally introduce properly.
\begin{gather}
    \alpha = \alpha_{i,\nu}+\alpha_{j,\mu}\\
    K_{AB} = \left(\frac{2\alpha_{i,\nu}\alpha_{j,\mu}}{\alpha\pi}\right)^\frac{3}{4}e^{-\frac{\alpha_{i,\nu}\alpha_{j,\mu}}{\alpha}R_{AB}^2}\\
    \pmb R_P = \frac{\alpha_{i,\nu}\pmb R_A+\alpha_{j,\mu}\pmb R_B}{\alpha}\\
    \phi(\alpha_{i,\mu},\pmb r-\pmb R_A)\phi(\alpha_{j,\nu},\pmb r-\pmb R_B) = K_{AB}\phi(\alpha,\pmb r-\pmb R_P)
\end{gather}
This rewrite only works if we also shift the polynomial prefactors to be relative to the product centre $R_P$, for all $u\in x,y,z$\cite[eq. 5.46]{daudel1983}:
\begin{equation}
\begin{split}
    (r_u-{R_A}_u)^{{l_A}_u} = &\sum_{m_i=0}^{{l_A}_u}\binom{{l_A}_u}{m_i}({R_P}_u-{R_A}_u)^{({l_A}_u-m_i)}(r_u-{R_P}_u)^{{l_A}_u}\\
    =&\sum_{m_i=0}^{{l_A}_u}v_{m_i}(r_u-{R_P}_u)^{{l_A}_u}
\end{split}
\end{equation}
\begin{figure}[H]
\begin{minted}{python}
def shift_polynomial(l_dim: int, difference_to_P_dim: float) -> list[float]:
    poly_coefficients = vector(l_dim+1)
    for m in range(l_dim+1):
        poly_coefficients[m] = comb(l_dim, m)*difference_to_P_dim**(l_dim-m)
    return poly_coefficients
\end{minted}
    \caption{Python code illustrating computation of the shifted polynomial coefficients.}
\end{figure}
If we multiply these shifted prefactors we get the prefactors for the product. 
\begin{equation}
\begin{split}
    (r_u-{R_A}_u)^{{l_A}_u}(r_u-{R_B}_u)^{{l_B}_u} = &\sum_{m_i=0}^{{l_A}_u}\sum_{m_j=0}^{{l_B}_u}v_{m_i}v_{m_j}(r_u-{R_P}_u)^{{l_A}_u+{l_B}_u}\\
    =&\sum_t^{{l_A}_u+{l_B}_u}v_t(r_u-{R_P}_u)^t
\end{split}
\end{equation}

In the code we compute the values of $v_t$ as a convolution:
\begin{figure}[H]
\begin{minted}{python}
def convolute(coef_A: list[float], coef_B: list[float]) -> list[float]:
    max_t = len(coef_A)+len(coef_B)
    poly_coefficients = vector(max_t+1)
    for i,ci in enumerate(coef_A):
        for j,cj in enumerate(coef_B):
            poly_coefficients[i+j] += ci*cj
    return poly_coefficients
\end{minted}
    \caption{Python code illustrating computation of the $R_P$ polynomial coefficients via a convolution.}
\end{figure}


To compute the integrals over the GTOs we can split them in terms of the 3 dimensions we are integrating over, $x,y$ and $z$. We can also pull the GTO normalisation terms out front. 
Each of these integrals can now be expanded using the analytical solution to Gaussian integrals of this form. All the integrals get solutions of the following form for even $t$\cite[eq. 5.53]{daudel1983}:
\begin{equation}
    i_t = \alpha^{-(t+1)/2}\frac{(t-1)!!}{2^{t/2}}\sqrt{\pi}
\end{equation}
And 0 for odd $t$.
The analytical solution to the integrals is independent of the direction so we can precompute them: 
\begin{figure}[H]
\begin{minted}{python}
def compute_gaussian_integral_factors(alpha:float, l_A:int, l_B:int)-> list[float]:
    factors = vector(l_A+l_B+3)
    for t in range(l_A+l_B+3):
        if t % 2 == 0:
            df = double_factorial(t-1)
            factors[t] = alpha**(-(t+1)/2) * (df/(2**(t/2))) * sqrt(pi)
        else:
            factors[t] = 0
    return factors
\end{minted}
    \caption{Python code illustrating computation of the integral factors for even and odd powers}
\end{figure}
We compute an extra $2$ factors to accommodate for the second moment. 
We then multiply each with the appropriate $v_t$ and sum over $t$\cite[eq. 5.49]{daudel1983}.
We also compute the higher moments\cite[sec. 5.2.2.5]{daudel1983} in the same code block in accordance with the sum:
\begin{equation}
    \sum_{t=0}^{l+M}\sum_{m=0}^M \binom{M}{m}{R_P}_u^{M-m}v_ti_t
\end{equation}
\begin{figure}[H]
\begin{minted}{python}
def compute_GTO_integrals(R_A: float, l_A: int, orbital_A: int, R_B: float, l_B: int, orbital_B: int, exponent_i: float, exponent_j: float, distance_between_A_B: float) -> tuple[float,list[float],list[float]]:
    alpha = exponent_i + exponent_j
    exponents = exponent_i * exponent_j
    K_AB = ((2*exponents)/(alpha*pi))**(3/4) * e**(-(exponents/alpha)*distance)
    integral_factors = compute_gaussian_integral_factors(alpha, l_A, l_B)
    zeroth_moment = vector(3)
    first_moment = vector(3)
    second_moment = vector(3)
    for dim in [x,y,z]:
        gaussian_product_center_in_dim = (exponent_i*R_A[dim]+exponent_j*R_B[dim])/alpha
        centre_relative_to_A = gaussian_product_center_in_dim-R_A[dim]
        centre_relative_to_B = gaussian_product_center_in_dim-R_B[dim]
        l_A_dim = angular_momentum_in_dimension[l_A][orbital_A][dim]
        l_B_dim = angular_momentum_in_dimension[l_B][orbital_B][dim]
        l_max_dim = max(l_A_dim, l_B_dim)
        vmis = shift_polynomial(l_A_dim, centre_relative_to_A)
        vmjs = shift_polynomial(l_B_dim, centre_relative_to_B)
        vts = convolute(vmis, vmjs)
        for t, vt in enumerate(vts):
            zeroth_moment[dim] += vt * integral_factors[t+m]
            for m in range(1+1):
                first_moment[dim] += comb(1,m) * gaussian_product_center_in_dim**(1-m) * vt * integral_factors[t+m]
            for m in range(2+1):
                second_moment[dim] += comb(2,m) * gaussian_product_center_in_dim**(2-m) * vt * integral_factors[t+m]

    overlap = zeroth_moment[x]*zeroth_moment[y]*zeroth_moment[z]
    dipol = vector(3)
    dipol[x] = first_moment[x]*zeroth_moment[y]*zeroth_moment[z]
    dipol[y] = zeroth_moment[x]*first_moment[y]*zeroth_moment[z]
    dipol[z] = zeroth_moment[x]*zeroth_moment[y]*first_moment[z]

    quadrupol = vector(6)
    quadrupol[xx] = second_moment[x]*zeroth_moment[y]*zeroth_moment[z]
    quadrupol[yy] = zeroth_moment[x]*second_moment[y]*zeroth_moment[z]
    quadrupol[zz] = zeroth_moment[x]*zeroth_moment[y]*second_moment[z]
    quadrupol[xy] = first_moment[x]*first_moment[y]*zeroth_moment[z]
    quadrupol[xz] = first_moment[x]*zeroth_moment[y]*first_moment[z]
    quadrupol[yz] = zeroth_moment[x]*first_moment[y]*first_moment[z]
    return overlap, dipol, quadrupol
\end{minted}
    \caption{Python code illustrating computation of the integral $\braket{\phi_i|\cdots|\phi_j}$ using the dimension-wise decomposition.}
\end{figure}
%\begin{equation}
%N^{G}_{i}(\alpha_i,\ell_x,\ell_y,\ell_z)
%= \sqrt{\left(\frac{2\alpha_i}{\pi}\right)^{3/2}
%\frac{(4\alpha_i)^{\ell}}{(2\ell_x-1)!!\,(2\ell_y-1)!!\,(2\ell_z-1)!!}},
%\end{equation}

\section{Building the Hückel Matrix}
As a part of computing the Hückel energy we need to construct the Hückel matrix.
The Hückel matrix comes from extended Hückel theory. Before we can construct it we need a few definitions. 
First the GFN2 type coordination number for atom $A$ is
\begin{gather}
    \begin{split}
        CN_A' = &\sum_{B\neq A}\left(1+e^{-10\left(\frac{4\left(R_{A,cov}+R_{B,cov}\right)}{3R_{AB}}-1\right)}\right)^{-1}\left(1+e^{-20\left(\frac{4\left(R_{A,cov}+R_{B,cov}+2\right)}{3R_{AB}}-1\right)}\right)^{-1}
    \end{split}
\end{gather}
Where $R_{A,cov}$ is the covalent atomic radius of $A$ specified for the GFN2 method.
Now with $EN_A$ being the Pauling electronegativity and $k_EN=0.02$ as well as $k_{A,l}^{\text{poly}}$ being GFN2 specific constants we define the following 3 functions:
\begin{gather}
    X(EN_A,EN_B) = 1 + k_{EN}(EN_A-EN_B)^2\\
    \Pi(R_{AB},l,l') = \left(1 + k^{\text{poly}}_{A,l}\left(\frac{R_{AB}}{R_{A,cov}+R_{B,cov}}\right)^\frac{1}{2}\right)\left(1 + k^{\text{poly}}_{B,l'}\left(\frac{R_{AB}}{R_{A,cov}+R_{B,cov}}\right)^\frac{1}{2}\right)\\
    Y(\zeta_{A,l},\zeta_{B,l'}) = \left(\frac{2\sqrt{\zeta_{A,l}\zeta_{B,l'}}}{\zeta_{A,l}+\zeta_{B,l'}}\right)^\frac{1}{2}
\end{gather}

The Hückel matrix is then calculated as follows:
\begin{align}
    H_{\nu\nu}^{EHT} &= H_A^l - H_{CN_A}CN_A'\\
    \mn{H^{EHT}} &= \frac{1}{2}K^{ll'}_{AB}\mn{S}(H^{EHT}_{\mu\mu}+H^{EHT}_{\nu\nu})\\
    &\cdot X(EN_A,EN_B)\notag\\
    &\cdot \Pi(R_{AB},l,l')\notag\\
    &\cdot Y(\zeta^A_l,\zeta^B_{l'}), \quad\quad \forall \mu \in l \in A, \nu \in l' \in B\notag
\end{align}

$K^{ll'}_{AB}$ is an element and shell specific fitted constant however, in GFN2 it only depends on the shells. 
$S_{\mu\nu}=\braket{\phi_\mu|\phi_\nu}$ is the just introduced overlap of the orbitals. 
$H^l_A$ and $H^l_{CN'_A}$ are both fitted constants. $EN_A$ is the electronegativity of the element of atom A, given in the original \texttt{xtb} code. 

\begin{figure}[H]
\begin{minted}{python}
def huckel_matrix(atoms: list[int], positions: list[list[float]], overlap: list[list[float]]) -> list[list[float]]:
    orbitals = get_orbitals(atoms)
    H_EHT = square_matrix(len(orbitals))
    CN = get_coordination_numbers(atoms,positions)
    for orbital_idx, (atom_idx,atom,subshell,orbital) in enumerate(orbitals):
        CN_A = CN[atom_idx]
        H_A = self_energy[atom][subshell] # constant
        H_CN_A = GFN2_H_CN_A[atom][subshell] # constant
        H_EHT[orbital_idx][orbital_idx] = H_A - H_CN_A*CN_A

    for idx_A,(atom_A_idx,atom_A,subshell_A,_) in enumerate(orbitals):
        l_A = angular_momentum_of_subshell[atom_A][subshell_A]
        EN_A = electro_negativity[atom_A]
        R_A = positions[atom_A_idx]
        Rcov_A = covalent_radii[atom_A]
        k_poly_A = k_poly[atom_A][l_A]
        for idx_B,(atom_B_idx,atom_B,subshell_B,_) in enumerate(orbitals):
            if idx_A == idx_B:
                continue
            l_B = angular_momentum_of_subshell[atom_B][subshell_B]
            EN_B = electro_negativity[atom_B]
            R_B = positions[atom_B_idx]
            Rcov_B = covalent_radii[atom_B]
            k_poly_B = k_poly[atom_B][l_B]
            K_ll = GFN2_K_AB[l_A][l_B]
            delta_EN_squared = (EN_A-EN_B)**2
            k_EN = 0.02
            X = 1+k_EN*delta_EN_squared
            R_AB = euclidean_distance(R_A,R_B) 
            Rcov_AB = Rcov_A + Rcov_B 
            PI = (1+k_poly_A*sqrt(R_AB/Rcov_AB)) * (1+k_poly_B*sqrt(R_AB/Rcov_AB))
            slater_exp_A = slater_exponent[atom_A][l_A]
            slater_exp_B = slater_exponent[atom_B][l_B]
            Y = sqrt((2*sqrt(slater_exp_A*slater_exp_B)) / (slater_exp_A+slater_exp_B))
            H_nn = H_EHT[idx_A][idx_A]
            H_mm = H_EHT[idx_B][idx_B]
            S_nm = overlap[idx_B][idx_B]
            H_EHT[idx_A][idx_B] = k_ll*(1/2)*(H_nn+H_mm)*S_nm*Y*X*PI
    return H_EHT
\end{minted}
\caption{Python code illustrating construction of the Hückel matrix}
\end{figure}
Using this we can now compute the Hückel energy where $P$ is the density matrix at this point in the SCC procedure:
\begin{equation}
    \E{EHT} = \sum_{\mu\nu}P_{\mu\nu}H^{EHT}_{\mu\nu}\\
\end{equation}



\begin{figure}[H]
\begin{minted}{python}
def huckel_energy(density_matrix:list[list[int]], huckel_matrix:list[list[int]]) -> float:
    E_EHT = 0
    orbitals = len(density_matrix)
    for shell_mu in range(orbitals):
        for shell_nu in range(orbitals):
            E_EHT += density_matrix[shell_nu][shell_mu] * huckel_matrix[shell_mu][shell_nu]
    return E_EHT
\end{minted}
\caption{Python code illustrating computation of the Hückel energy}
\end{figure}


\section{Repulsion Energy}
The repulsion energy in GFN2-xTB is computed classically using the following formula:
\begin{align}
    \E{rep} &= \frac{1}{2}\sum_{A}\sum_{B\neq A}\frac{Z^{eff}_A Z^{eff}_B}{R_{AB}}e^{-\sqrt{a_Aa_B}(R_{AB})^{(k_f)}}\\
k_f &= \begin{cases}1 & if A,B\in\{\text{H},\text{He}\}\\\frac{3}{2}&otherwise\end{cases} 
\end{align}
The effective nuclear charge $Z^{eff}$ and $a$ are variables fitted for each element. 
$R_{AB}$ is the distance between the A and B atoms.
This can be implemented in the following way:

\begin{figure}[H]
\begin{minted}{python}
H = 0
He = 1
def repulsion_energy(atoms: list[int], positions : list[list[float]]) -> float:
    sum = 0
    for idx_A, (atom_A, position_A) in enumerate(zip(atoms, positions)):
        for idx_B, (atom_B, position_B) in enumerate(zip(atoms, positions)):
            if idx_A == idx_B:
                continue
            k_f = 3/2
            if atom_A in [H, He] and atom_B in [H, He]:
                k_f = 1
            R_AB = euclidean_distance(position_A, position_B)
            alpha_A = repulsion_alpha[atom_A]
            alpha_B = repulsion_alpha[atom_B]
            Y_A = effective_nuclear_charge[atom_A]
            Y_B = effective_nuclear_charge[atom_B]
            sum += ((Y_A*Y_B)/R_AB) * e ** ( - sqrt(alpha_A*alpha_B) * R_AB**k_f )
    E_rep = (1/2)*sum
    return E_rep
\end{minted}
\caption{Python code illustrating computation of the repulsion energy}
\end{figure}

\section{Isotropic Energy}
The isotropic energy terms $\E{\gamma}$ and $\E{\Gamma}$ require us to first do a Mulliken population analysis to get the subshell-wise partial Mulliken charges $q_{A,l}$.
\begin{equation}
    q_{A,l} = \sum_{\mu\in l}\sum_B\sum_{l'\in B}\sum_{\nu\l'}P_{\mu\nu}S_{\mu\nu}\\
\end{equation}

With $\eta_A$ being an element specific constant and $k_{A,l}$ being a shell specific constant we define, both specific to the parametrisation of GFN2:
\begin{equation}
    \eta = \frac{(1+k_{A,l})\eta_A+(1+k_{B,l'})\eta_B}{2}\\
\end{equation}

\begin{equation}
    \gamma_{AB,ll'} = \sqrt{\frac{1}{R_{AB}^2+\eta^{-2}}}
\end{equation}
We can then define one of the two parts of the isotropic energy, $\E{\gamma}$
\begin{equation}
    \E{\gamma} = \frac{1}{2}\sum_{A,B}^{N_{atoms}}\sum_{l\in A}\sum_{l'\in B}q_{A,l}q_{B,l'}\gamma_{AB,ll'}\label{eq:gamma}
\end{equation}
With the element and shell specific GFN2 constant $\Gamma_{A,l}$ we also get the definition for the other part:
\begin{equation}
    \E{\Gamma} = \frac{1}{3}\sum_A^{N_{atoms}}\sum_{l\in A}(q_{A,l})^3\Gamma_{A,l} \label{eq:Gamma}
\end{equation}



\section{Anisotropic Electrostatic Energy} \label{sec:AES}

The anisotropic electrostatic energy term $E_{AES}$ is supposed to capture changes in the energy for electrostatic interactions that arise from anisotropic density distributions (polarization). It represents the energy caused by charge-dipole interactions and charge-quadrupole interactions.

Below we introduce all the necessary definitions for the energy term.
$\pmb{\mu}_A$ is the cumulative atomic dipole moment of atom A, and $\pmb{\Theta}_A$ as the corresponding traceless quadrupole moment. The superscript $T$ is the vector transpose operation.

\begin{equation}
    \pmb{\mu}_A = 
    \begin{pmatrix}
        \mu_A^{x}&
        \mu_A^{y}&
        \mu_A^{z}\\
    \end{pmatrix}^T
\end{equation}

\begin{equation}
    \pmb{\Theta}_A = 
    \begin{pmatrix}
        \Theta_A^{xx} & \Theta_A^{xy} & \Theta_A^{xz}\\
        \Theta_A^{yx} & \Theta_A^{yy} & \Theta_A^{yz}\\
        \Theta_A^{zx} & \Theta_A^{zy} & \Theta_A^{zz}\\
    \end{pmatrix}
\end{equation}

$\Theta_A^{uv}$ is a specific element in the traceless quadrupole moment matrix for A.

\begin{equation}
\begin{split}
        \Theta_A^{uv} &= \frac{3}{2} \theta_A^{uv} - \frac{\delta_{uv}}{2} (\theta_A^{xx} + \theta_A^{yy} + \theta_A^{zz})\\
\end{split}
\end{equation}


Below we define the zeroth, first, and second order cumulative atomic multipole moments (CAMM) $q_A$, $\mu_A^u$, and $\theta_A^{uv}$.

\begin{equation}
\begin{split}
    q_A &= Z_A - \sum_{l \in A} q_{A,l}\\
\end{split}
\end{equation}

$q_A$ is the Mulliken charge for an atom A. $Z_A$ is the number of protons in the atom A. $q_{A,l}$ is the previously defined partial Mulliken charge.

\begin{equation}
\begin{split}
        \mu_A^u &= \sum_{l \in A} \sum_{\kappa \in l} \sum_{B} \sum_{l' \in B} \sum_{\lambda \in l'} P_{\kappa \lambda} (R_{A_u} S_{\lambda \kappa} - D_{\lambda \kappa}^u)\\
\end{split}
\end{equation}

$\mu_A^u$ is the cumulative atomic dipole moment for a specific dimension $u$ of atom A. $D_{\lambda \kappa}^u$ is an element in the dipole tensor.

\begin{equation}
\begin{split}
        \theta_A^{uv} &= \sum_{l \in A} \sum_{\kappa \in l} \sum_{B} \sum_{l' \in B} \sum_{\lambda \in l'} P_{\kappa \lambda} (R_{A_u} D_{\lambda v}^v + R_{A_v} D_{\lambda \kappa}^u - R_{A_u} R_{A_v} S_{\lambda \kappa} - Q_{\lambda \kappa}^{uv})\\
\end{split}
\end{equation}

The Cartesian components $u$ and $v$ are the dimensions for which we compute the second order CAMM.
%$D_{\lambda \kappa}^\alpha$ and $Q_{\lambda \kappa}^{\alpha \beta}$ are the electric dipole and quadrupole moment integrals between the AOs $\phi_\kappa$ and $\phi_\lambda$.


At short distances the terms are dampened to avoid divergence for the AES energy. The distance dependent damping function is given by:

\begin{equation}
\begin{split}
        f_n(R_{AB}) &=  \frac{1}{R_{AB}^n} \times \frac{1}{1 + 6 \left(\frac{R_0^{AB}}{R_{AB}}\right)^{a_n}}\\
\end{split}
\end{equation}

$a_n$ are adjusted global parameters and $R_{AB}^n$ is the distance to the power of $n$. 

\[
  a_3 = 3.0 \quad\quad a5 = 4.0
\]

Now we have all the definitions needed for the anisotropic electrostatic energy, which is given by:

\begin{equation}
\begin{split}
    \E{AES} &= \E{q\mu}+\E{q\Theta} + \E{\mu\mu}\\
    &= \frac{1}{2}\sum_{A,B}\{f_3(R_{AB})[q_A(\pmb{\mu}_B^T\pmb{R}_{BA})+q_B(\pmb{\mu}_A^T\pmb{R}_{AB})]\\
    &\quad + f_5(R_{AB})[q_A\pmb{R}_{AB}^T\pmb{\Theta}_B\pmb{R}_{AB}+q_B\pmb{R}_{AB}^T\pmb{\Theta}_A\pmb{R}_{AB}\\
    &\quad -3(\pmb{\mu}_A^T\pmb{R}_{AB})(\pmb{\mu}_B^T\pmb{R}_{AB}) + (\pmb{\mu}_A^T\pmb{\mu}_B)R_{AB}^2] \}\\
\end{split}
\end{equation}


\section{Anisotropic Exchange Correlation}

The anisotropic exchange correlation term $E_{AXC}$ is supposed to capture changes in the atomic exchange (XC) energy that arise from anisotropic density distributions (polarization). It represents the energy caused by charge-dipole interactions and charge-quadrupole interactions.

\begin{equation}
\begin{split}
        \E{AXC} &= \sum_{A} (f_{XC}^{\mu_A} |\pmb{\mu}_A|^2 + f_{XC}^{\Theta_A} ||\pmb{\Theta}_A||^2)\\
\end{split}
\end{equation}

In the equation we have the constants $f_{XC}^{\mu_A}$ and $f_{XC}^{\Theta_A}$, which are fitted element-specific parameters. The values for each element can be found in the supporting information of the GFN2-xTB paper\cite{bannwarth2019}.
We already defined both $\pmb{\mu}_A$ and $\pmb{\Theta}_A$ in \autoref{sec:AES}. 

\section{Electronic Entropy}
In GFNn-xTB they use the following term to assign the (spin restricted) fractional orbital occupations. It is based on the eigenvalues from diagonalising $FC=SC\varepsilon$ where F is the GFN2-xTB equivalent of a Fock matrix, and C is the matrix of GTO contraction coefficients. S is the overlap matrix and $\varepsilon$ is the diagonal matrix of eigen values. The electronic temperature $T_{el}=300$ kelvin is non-zero and thus we have fractional occupations $n_{i\sigma}$ for the $i$'th molecular spin orbital with spin $\sigma$ chosen based on the Fermi-distribution:: 
\begin{equation}
    n_{i\sigma} = \frac{1}{e^{(\varepsilon_{ii}-\varepsilon^\sigma_F)/(K_BT_{el})}+1}
\end{equation}
with the Fermi level $\varepsilon_F^\sigma$ chosen such that the following equation holds $\sum_in_{i\sigma}=N_{\sigma}$. Here $K_B$ is the Boltzmann constant. $N_\alpha=\frac{N-N_f}{2}+N_f $ and $N_\beta=\frac{N-N_f}{2}$ is based on the total number of electrons $N=C+\sum_AZ_A$ and the requested number of free electrons $N_f$ with the restriction that $0\leq N-N_f$ is even. $C$ is the requested total charge. 
The Fermi energy term is then:
\begin{equation}
    G_{Fermi} = K_BT_{el}\sum_{\sigma\in\alpha,\beta}\sum_in_{i\sigma}\ln(n_{i\sigma}) + (1-n_{i\sigma})\ln(1-n_{i\sigma})
\end{equation}
This repeated diagonalising is one of the more computationally demanding tasks for the GFNn-xTB methods. 



\section{Dispersion Energy}

The dispersion energy term is used to include the energy caused by London dispersion forces.

A London dispersion force is a temporary attractive force that occurs when electrons in two adjacent atoms occupy positions that causes the atoms to form temporary dipoles\cite{purdue-dispersion}.

%The dispersion energy is the weak, attractive forces that appear from temporary fluctuations in the electron distribution around a molecule.
This happens from temporary fluctuations in the electron distribution around a molecule. Expansions and contractions of the atomic density will therefore respectively incerase and decrease the magnitude or the interation\cite{bannwarth2019}.

%The D4' dispersion model treats dispersion interactions by means of a self-consistent variant of the recently published D4 dispersion model\cite{bannwarth2019}.

%D4' include effects up to second order within the self-consistent formulation of the D4 dispersion model.

The two-body London dispersion energy is given by

\begin{equation}
\begin{split}
        -\sum_{A>B} \sum_{n=6,8} s_n \frac{C_n^{AB} (q_A, CN^A_{cov}, q_B, CN^B_{cov})}{R^n_{AB}} f^{(n)}_{damp,BJ} (R_{AB})
\end{split}
\end{equation}

The values $q_A$ and $q_B$ are the Mulliken charges for the atoms, and the scaling parameters $s_n$ are defined as
\[
  s6 = 1.0 \quad\quad s8 = 2.7
\]

The Becke–Johnson (BJ) damping function is used because it has shown to provide better results for nonbonded distances\cite{grimme2011}, which are the only type of distances we consider in xTB methods.
With it, no pair-speciﬁc cut-off radii are required and no artiﬁcial repulsive interatomic forces at short distances are present. The BJ damping function is given by

\begin{equation}
\begin{split}
        f_{damp,BJ}^{(n)} (R_{AB}) = \frac{R_{AB}^n}{R_{AB}^n + (a_1 R_{AB}^0 + a_2)^n}\label{eq:damp-bj}\\
\end{split}
\end{equation}

\autoref{eq:damp-bj} is taken from \cite{bannwarth2021} where they raise the parenthesised term in the denominator to the power of n, whereas the constant 6 is used in the GFN2 paper\cite{bannwarth2019}. We do not have an explanation for this, so it is worth taking note of this discrepancy.


The global damping parameters are
\[
  a1 = 0.52 \quad\quad a2 = 5.0
\]
and the damping constant is given by

\begin{equation}
\begin{split}
        R_{AB}^0 = \sqrt{C_8^{AB} / C_6^{AB}}\\
\end{split}
\end{equation}



\(C_6^{AB}\) is the pairwise dipole-dipole dispersion coefficients calculated by numerical integration as given by
\begin{equation}
  C_6^{AB} = \frac{3}{\pi} \sum_{j} w_j \overline{\alpha}_A (i\omega_j, q_A, CN_{cov}^A)\overline{\alpha}_B (i\omega_j, q_B, CN_{cov}^B)
\end{equation}



\(C_9^{ABC}\) is the triple-dipole constant and is given by
\begin{equation}
  C_9^{ABC} = \frac{3}{\pi} \int_0^\infty \alpha^A(i\omega) \alpha^B(i\omega)\alpha^C(i\omega)d\omega
\end{equation}

This three-body contribution is typically \(<5-10\%\) of \(E_{disp}\), so it is small enough that we can reasonably approximate the coefficients by a geometric mean as\cite{grimme2010}


\begin{equation}
  C_9^{ABC} \approx -\sqrt{C_6^{AB} C_6^{AC} C_6^{BC}}
\end{equation}



\(C_8^{AB}\) is calculated recursively from the lowest order \(C_6^{AB}\) coefficients.
\begin{equation}
  C_8^{AB} = 3C_6^{AB} \sqrt{\mathcal{Q}^A\mathcal{Q}^B}
\end{equation}

\begin{equation}
  \mathcal{Q}^A = s_{42} \sqrt{Z^A} \frac{\braket{r^4}^A}{\braket{r^2}^A}
\end{equation}

We have not been able to find $s_{42}$ nor the fraction in any related research papers or supporting material, but we were able to find both in the code for the dftd4 project\footnote{\url{https://github.com/dftd4/dftd4}}. The whole term $\mathcal{Q}^A$ is stored as an array of element-specific constants, named \verb|sqrt_z_r4_over_r2|, with $s_{42}$ set to $0.5$. Lastly we have $Z^A$, which is the atomic number of A.

\autoref{eq:ATM-term} is the Axilrod–Teller–Muto (ATM) term, which describes the three-body interaction energy between atoms, and \autoref{eq:ATM-damping} is the corresponding zero-damping function for the term.

\begin{equation}
\begin{split}
        -s_9 \sum_{A>B>C} \frac{(3cos(\theta_{ABC})cos(\theta_{BCA})cos(\theta_{CAB})+1)C_9^{ABC}(CN_{cov}^A,CN_{cov}^B,CN_{cov}^C)}{(R_{AB} R_{AC} R_{BC})^3} \label{eq:ATM-term}
\end{split}
\end{equation}

\begin{equation}
\begin{split}
        f^{(9)}_{damp,zero}(R_{AB},R_{AC},R_{BC}) \label{eq:ATM-damping}
\end{split}
\end{equation}


The scaling parameter $s_9$ is $5.0$, and the values \(\theta_{ABC}\), \(\theta_{BCA}\), and \(\theta_{CAB}\) are the angles between the edges going from B, C, and A to the other two atoms respectively.





%The last term is the charge-independent three-body dispersion term, which incorporates the dorminant part of the many-body dispersion energy.

The final D4' energy term is given by


\begin{equation}
\begin{split}
  \E{disp}^{D4'} = &-\sum_{A>B} \sum_{n=6,8} s_n \frac{C_n^{AB} (q_A, CN^A_{cov}, q_B, CN^B_{cov})}{R^n_{AB}} f^{(n)}_{damp,BJ} (R_{AB}) \\
  &-s_9 \sum_{A>B>C} \frac{(3cos(\theta_{ABC})cos(\theta_{BCA})cos(\theta_{CAB})+1)C_9^{ABC}(CN_{cov}^A,CN_{cov}^B,CN_{cov}^C)}{(R_{AB} R_{AC} R_{BC})^3} \\
  &\times f^{(9)}_{damp,zero}(R_{AB},R_{AC},R_{BC})
\end{split}
\end{equation}


%The dispersion energy is the last term 
