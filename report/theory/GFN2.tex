\chapter{Theory}
\section{GFN2-xTB}
GFN2-xTB is a part of the GFNn-xTB (Geometry, Frequency, Non covalent, eXtended Tight Binding) family of semi-empirical methods for computational chemistry. 
The method gives good approximations for molecular geometries, vibrational frequencies, and non-covalent interaction energies but also does well on a variety other properties. 
Over all it strives to hit a balance between being accurate, close to the physics, general over a wide range of elements and not too computationally expensive.
This is achieved by approximating a true quantum mechanical simulation, using carefully chosen approximations and parameters. 
In contrast to forcefield methods that often operate on the level of atoms or even functional groups interacting the method is still treating the calculations at the level of individual shells in many places. 
GFN2-xTB uses A Self-Consistent Charges approach i.e. it makes an initial guess at a density matrix and an energy which it then iteratively refines until both have converged. 

\begin{figure}[H]
\begin{minted}{python}
def get_GFN2_energy(atoms: list[int], positions : list[list[float]]) -> float:
    density = P(atoms)
    overlap = S(atoms, positions)
    dipol_dipol = D(atoms, positions, overlap)
    charge_quadrupol = Q(atoms, positions, overlap, dipol_dipol)
    initial_hamiltonian = H0(atoms, positions)
    huckel_theory_matrix = H_EHT(atoms, positions, overlap, initial_hamiltonian)
    charges = mulliken_population_analysis(density,atoms)
    E_repulsion = repulsion(atoms, positions)
    E_dispersion = D4Prime(charges, atoms, positions)
    E_huckel = Huckel(density, extended_huckel_theory_matrix)
    E_anisotropic = AES(charges, overlap, dipol_dipol, charge_quadrupol, positions)
    E_isotropic = IES(charges, positions)
    E = E_repulsion + E_dispersion + E_huckel + E_anisotropic + E_isotropic
    # ...
    while not (energy_converged and densities_converged):
        eigen_values = diagonalize(hamiltonian, overlap) # HC=SCe 
        new_density = compute_density_matrix_from_fermi(eigen_values,...)
        # ... update everything with new density
        energy_converged = (E-E_new)**2 < tolerance
        densities_converged = error_squared(density,new_density) < tolerance
        E = E_new
        density = new_density
\end{minted}
\caption{Python like code illustrating the main loop of a GFN2-xTB implementation.
Line 2-14 computes the energy in a non SCC manner, line 15-23 iteratively improves the energy using SCC.
}
\end{figure}
Let us define a small helper function to decrease the amount of indentation in the later code examples. 
\begin{figure}[H]
\begin{minted}{python}
def get_orbitals(atoms: list[int]) -> list[tuple[int]]:
    orbitals = []
    for atom_idx,atom in enumerate(atoms):
        for subshell in range(number_of_subshells[atom]):
            l = angular_momentum_of_subshell[atom][subshell] 
            for orbital in range(l*2+1):
                orbitals.append((atom_idx,atom,subshell,orbital))
    return orbitals
\end{minted}
\caption{Python like code for generating a convenient list of orbitals to iterate though. }
\end{figure}
And a helper function to create a square matrix.
\begin{figure}[H]
\begin{minted}{python}
def get_square_matrix(n: int) -> list[list[float]]:
    matrix = []
    for _ in range(n):
        row = []
        for _ in range(n):
            row.append(0.0)
        matrix.append(row)
    return matrix
\end{minted}
\caption{Python like code for generating a square matrix.}
\end{figure}


The initial density matrix guess is formulated as a superposition of neutral atomic reference densities $P_0 = \sum_{A}P_{A_0}$. This means that we let $P_0$ be a diagonal matrix that is $n$ by $n$ where $n$ is the total number of orbitals across the whole molecule. The values on the diagonal are the fractional number of electrons in the orbitals, the fractional occupations. The shells are filled from the nucleus and outwards. 
\begin{figure}[H]
\begin{minted}{python}
def density_initial_guess(atoms: list[int]) -> list[list[float]]:
    orbitals = get_orbitals(atoms)
    occs = get_square_matrix(len(orbitals))
    for idx,(_,atom,subshell,_) in enumerate(orbitals):
        l = angular_momentum_of_subshell[atom][subshell] 
        orbitals_in_subshell = l*2+1 
        electrons_in_subshell = reference_occupations[atom][subshell]
        electrons_per_orbital = electrons_in_subshell/orbitals_in_subshell
        occs[idx][idx] = electrons_per_orbital
    return occs
\end{minted}
\caption{Python like code illustrating computation of $P_0$}
\end{figure}
For fullerenes the guess is simply all ones on the diagonal as number\_of\_subshells[C] = 2, angular\_momentum\_of\_subshell[C] = [0,1,0] and reference\_occupations[C] = [1.0,3.0,0.0]. Thus occ will be a repeating series of [$\frac{1.0}{1},\frac{3.0}{3},\frac{3.0}{3},\frac{3.0}{3}$].
We also need the overlap matrix, $S$, which is computed in the following way.
\begin{equation}
S_{\nu\mu} = \braket{\psi_\nu|\psi_\mu}\quad\quad\quad\quad\forall \nu \in l \in A,\mu \in l' \in B
\end{equation}
This is an integral between two Slater type orbitals (STOs). To compute this we need to remember that in GFN2-xTB a STO is approximated as a linear combination of gaussian type orbitals:
\begin{equation}
    \begin{split}
        \ket{\psi_\nu} =&\psi(\zeta_{A,l},r-R_A) = \sqrt{\frac{\zeta_{A,l}^3}{\pi}}e^{-\zeta_{A,l}|r-R_A|}\\
        \approx &\sum_i^{N_{A,l}}c_{i,\nu}\left(\frac{2\alpha_{i,\nu}}{\pi}\right)^{3/4}e^{\alpha_{i,\nu}|r-R_A|}=\sum_i^{N_{A,l}}c_{i,\nu}\phi(\alpha_{i,\nu},r-R_A) = \sum_i^{N_{A,l}}c_{i,\nu}\ket{\phi_i}
    \end{split}
\end{equation}
Where $N_{A,l}$ is a element and shell dependant constant, it is the number of GTOs used to approximate the STO. The contraction coefficient $c$ is a fitted value. 

\begin{equation}
    S_{\nu\mu} =\sum_i^{N_{A,l}}\sum_j^{N_{B,l'}}c_{i,\nu}c_{j,\mu} \braket{\phi_i|\phi_j}
\end{equation}
As these are real valued functions we can drop the conjugation too.
\begin{equation}
    \begin{split}
        \braket{\phi_i|\phi_j} = &\int \phi^*(\alpha_{i,\nu},r-R_A)\phi(\alpha_{j,\mu},r-R_B)\,dx\,dy\,dz\\
        =&\int \phi(\alpha_{i,\nu},r-R_A)\phi(\alpha_{j,\mu},r-R_B)\,dx\,dy\,dz\\
    \end{split}
\end{equation}
Now we see that we have to compute the products of GTOs. The product of two Gaussians is a new Gaussian centred at a point between the two.
\begin{gather}
    \phi(\alpha_{i,\mu},r-R_A)\phi(\alpha_{j,\nu},r-R_B) = K_{AB}\phi(\alpha,r-R_P)\\
    \alpha = \alpha_{i,\nu}+\alpha_{j,\mu}\\
    K_{AB} = \left(\frac{2\alpha_{i,\nu}\alpha_{j,\mu}}{\alpha\pi}\right)^\frac{3}{4}e^{-\frac{\alpha_{i,\nu}\alpha_{j,\mu}}{\alpha}|R_A-R_B|^2}\\
    R_P = \frac{\alpha_{i,\nu}R_A+\alpha_{j,\mu}R_B}{\alpha}
\end{gather}
To compute the integral over the GTOs we can split it in terms of the 3 dimensions we are integrating over, x,y and z.
\begin{equation}
    \begin{split}
        \int \phi(\alpha_{i,\nu},r-R_A)\phi(\alpha_{j,\mu},r-R_B)\,dx\,dy\,dz=K_{AB}&\int \phi(\alpha,r-R_P)\,dx\,dy\,dz\\
        =K_{AB}&\int \phi(\alpha,r_z-{R_P}_z)\,dx\\
            \times&\int \phi(\alpha,r_y-{R_P}_y)\,dy\\
            \times&\int \phi(\alpha,r_z-{R_P}_z)\,dz\\
    \end{split}
\end{equation}
For clarity let us in the following code snippets have the following constants:
\begin{figure}[H]
\begin{minted}{python}
    x = 0
    y = 1
    z = 2
    xx = 0
    yy = 1
    zz = 2
    xy = 3
    xz = 4
    yz = 5
    directions = 6
\end{minted}
\caption{Constants for the order of directions.}
\end{figure}

\begin{figure}[H]
\begin{minted}{python}
def overlap(atoms: list[int], positions:list[list[float]]) -> list[list[float]]:
    orbitals = get_orbitals(atoms)
    S = get_square_matrix(len(orbitals))
    for idx_A, (atom_idx_A,atom_A,subshell_A,orbital_A) in enumerate(orbitals):
        for idx_B, (atom_idx_B,atom_B,subshell_B,orbital_B) in enumerate(orbitals):
            R_A = positions[atom_idx_A]
            R_B = positions[atom_idx_B]
            l_A = angular_momentum_of_subshell[atom_A][subshell_A]
            l_B = angular_momentum_of_subshell[atom_B][subshell_B]
            distance = euclidean_distance_squared(R_A,R_B)
            S[idx_A][idx_B] = compute_STO_integral(...)
    return S
\end{minted}
\caption{Python snippet illustrating construction of $S$.}
\end{figure}
\begin{figure}[H]
\begin{minted}{python}
def compute_STO_integral(...)-> float:
    number_of_gaussians_A = number_of_gaussians[atom_A][subshell_A]
    number_of_gaussians_B = number_of_gaussians[atom_B][subshell_B]
    slater_exponent_A = slater_exponents[atom_A][subshell_A]
    slater_exponent_B = slater_exponents[atom_B][subshell_B]
    overlap = 0
    for gaussian_i in range(number_of_gaussians_A):
        for gaussian_j in range(number_of_gaussians_B):
            exponent_i = normalised_gaussian_exponent(...)
            exponent_j = normalised_gaussian_exponent(...)
            contraction_i = normalised_contraction_coeficient(...)
            contraction_j = normalised_contraction_coeficient(...)
            overlap += contraction_i*contraction_j*compute_GTO_integral(...)
    return overlap
\end{minted}
    \caption{Python snippet illustrating construction of the integral $\braket{\psi_\nu|\psi_\mu}$.}
\end{figure}
\begin{figure}[H]
\begin{minted}{python}
def normalised_gaussian_exponent(atom:int, subshell:int, gaussian:int, slater_exponent:float) -> float:
    normalisation_factor = slater_exponent**2
    return gaussian_exponents[atom][subshell][gaussian]*normalisation_factor

def normalised_contraction_coefficient(atom:int, subshell:int, gaussian:int, gaussian_exponent:float) -> float:
    l = angular_momentum_of_subshell[atom][subshell]
    normalization_factor = (((2.0*gaussian_exponent)/pi)**(3/4)) * (sqrt(4*gaussian_exponent)**l) / sqrt(double_factorial(l))
    return contraction_coeficients[atom][shell][gaussian]*normalisation_factor

def double_factorial(n:int) -> int:
    if n <= 1:
        return 1
    return n*double_factorial(n-2)
\end{minted}
    \caption{Python snippet illustrating normalisation of the gaussian exponents and contraction coefficients.}
\end{figure}
\begin{figure}[H]
\begin{minted}{python}
def compute_GTO_integral(...)-> float:
    overlap = 0
    alpha = exponent_i + exponent_j
    exponents = exponent_i * exponent_j
    K_AB = ((2*exponents)/(alpha*pi))**(3/4) * e**(-(exponents/alpha)*distance)
    for dim in [x,y,z]:
        gaussian_product_center = (exponent_i*R_A[dim]+exponent_j*R_B[dim])/alpha
        center_relative_to_A = gaussian_product_center-R_A[dim]
        center_relative_to_B = gaussian_product_center-R_B[dim]
        l_A_dim = angular_momentum_in_dimension[l_A][orbital_A][dim]
        l_B_dim = angular_momentum_in_dimension[l_B][orbital_B][dim]
        l_max_dim = max(l_A_dim, l_B_dim)
        exponents = [] 
    return overlap
\end{minted}
    \caption{Python like code illustrating computation of the integral $\braket{\phi_i|\phi_j}$}
\end{figure}
NOTE(Asmus) Explain D and Q as well


The huckel matrix is calculated using extended huckel theory. This is the calculation.
\begin{gather}
    H_{\nu\nu} = H_A^l - H_{CN_A}CN_A' \quad\quad\quad\quad\forall \nu \in l \in A\\
    \begin{split}
        CN_A' = &\sum_{B\neq A}\left(1+e^{-10\left(\frac{4\left(R_{A,cov}+R_{B,cov}\right)}{3R_{AB}}-1\right)}\right)^{-1}\left(1+e^{-20\left(\frac{4\left(R_{A,cov}+R_{B,cov}+2\right)}{3R_{AB}}-1\right)}\right)^{-1}
    \end{split}
\end{gather}
\begin{figure}[H]
\begin{minted}{python}
def huckel_matrix(atoms: list[int], positions: list[list[float]], overlap: list[list[float]]) -> list[list[float]]:
    orbitals = get_orbitals(atoms)
    H_EHT = get_square_matrix(len(orbitals))
    CN = get_coordination_numbers(atoms,positions)
    for orbital_idx, (atom_idx,atom,subshell,orbital) in enumerate(orbitals):
        CN_A = CN[atom_idx]
        H_A = self_energy[atom][subshell] # constant
        H_CN_A = GFN2_H_CN_A[atom][subshell] # constant
        H_EHT[orbital_idx][orbital_idx] = H_A - H_CN_A*CN_A

    for idx_A,(atom_A_idx,atom_A,subshell_A,_) in enumerate(orbitals):
        l_A = angular_momentum_of_subshell[atom_A][subshell_A]
        EN_A = electro_negativity[atom_A]
        R_A = positions[atom_A_idx]
        Rcov_A = covalent_radii[atom_A]
        k_poly_A = k_poly[atom_A][l_A]
        for idx_B,(atom_B_idx,atom_B,subshell_B,_) in enumerate(orbitals):
            if idx_A == idx_B:
                continue
            l_B = angular_momentum_of_subshell[atom_B][subshell_B]
            EN_B = electro_negativity[atom_B]
            R_B = positions[atom_B_idx]
            Rcov_B = covalent_radii[atom_B]
            k_poly_B = k_poly[atom_B][l_B]
            K_ll = GFN2_K_AB[l_A][l_B]
            delta_EN_squared = (EN_A-EN_B)**2
            k_EN = 0.02
            X = 1+k_EN*delta_EN_squared
            R_AB = euclidean_distance(R_A,R_B) 
            Rcov_AB = Rcov_A + Rcov_B 
            PI = (1+k_poly_A*sqrt(R_AB/Rcov_AB)) * (1+k_poly_B*sqrt(R_AB/Rcov_AB))
            slater_exp_A = slater_exponent[atom_A][l_A]
            slater_exp_B = slater_exponent[atom_B][l_B]
            Y = sqrt((2*sqrt(slater_exp_A*slater_exp_B)) / (slater_exp_A+slater_exp_B))
            H_nn = H_EHT[idx_A][idx_A]
            H_mm = H_EHT[idx_B][idx_B]
            S_nm = overlap[idx_B][idx_B]
            H_EHT[idx_A][idx_B] = k_ll*(1/2)*(H_nn+H_mm)*S_nm*Y*X*PI
    return H_EHT
\end{minted}
\caption{Python like code illustrating construction of $H_{KK}$}
\end{figure}


