\section{Methodology}

\subsection{Testing}

The xTB algorithm computes a lot of different energies, corrections, and other additions to the energy terms. There is a lot of overlap between the different variants of xTB, so even focusing on just one of them still requires a great amount of code.
Dealing with large computations with so many small parts makes proper validation especially important, as it becomes increasingly easy to make mistakes.
In the case of the xTB algorithm, the original Fortran implementation becomes an important point of reference for comparison. Throughout the coding process it became apparent that the xTB implementation by the Grimme research group does not match the equations described in the original xTB paper by the same authors.

% TODO: Give examples of code that does not follow the paper!

With this realization the obvious approach forward was to lean towards the existing implementation rather than the paper. This choice would allow us to continue doing validation against the existing code as a reference.

One of the hurdles from testing against an existing program becomes the lack of transparency regarding the logic that takes place between the initial input and the final output presented to the user. Thankfully, the source code is publicly available allowing for easy manipulation of the original flow of execution, thus avoiding the hassle of testing against a black box or the need to resort to methods of reverse engineering.

On behalf of these considerations it was decided to write patches that allow to intercept the arguments and results of arbitrary functions just by running the program as normal. This meant that smaller parts could be implemented without the need to implement all the code needed to compute its arguments.

An important part of any software is reproducability, and applying certain patches in certain scenarios is something that should preferably be automated, reproducable, and optimally also portable. This is especially important for this approach to validation as it requires a way to reproduce a specific version of xTB linked to the same versions of dependencies. Essentially an exact copy of the original shell environment to ensure that patches work, results are the same, and no new bugs appear in the program itself or its dependencies. All of this should be achievable without having to add, remove, downgrade or upgrade system packages on your system.

The well-known contenders for this is any of the numerous containerization solutions on Linux, such as Docker, Podman, LXC etc. There are some problems with these options though, one being that it can be difficult to truly reproduce package versions without saving the resulting container image, another being that it does not solve the problem of having multiple versions of the same package installed. Some other notable limitations are that it limits the process to run within the container and passing in a GPU or other hardware can be nefariously difficult. A container also does not have access to the X or Wayland session needed to run GUI applications, though that is not currently relevant in this case.

Another approach which has been growing in popularity in recent years are tools that take unique approaches to package management in order to make not only packages reproducable, but also shell environments, system configurations and other forms of "outputs". Two such popular package managers are Nix from the Nix team and Guix from the GNU foundation. Nix is arguably the more popular option and it is also the solution that has been chosen for this project.

Nix is an umbrella term that can refer to either the Nix functional programming language, the package manager, or the Nix based Linux distribution NixOS. The language and package manager go hand in hand and can be used on any Linux distribution. As such, NixOS is not required for the needs of this project and will not be mentioned going forward.

Nix does not follow the Unix Filesystem Hierarchy Standard (FHS), which brings with it some challenges, but this fundamental difference from other package managers is a major part of what makes Nix so powerful.
Rather than installing packages into the usual system paths like `/bin`, `/lib` etc. Nix installs everything into a read-only path called the Nix store under `/nix/store`.
Everything in the Nix store is a result of a core concept in Nix called a derivation, which is essentially a build task to produce some output of files into the Nix store.
All outputs into the store is marked with a custom hash in the filename called a NAR hash. These fundamental ideas fix some common problems such as circular dependencies and allow having multiple versions of the same package installed as they will simply coincide in the Nix store with different NAR hashes.

The typical binary on Linux is dynamically linked against the FHS compliant paths and it is not uncommon to have them hardcoded either. To make use of the packages in the Nix store, it is required to either recompile the program against the store paths, or in the case of proprietary software, patching the ELF header is needed to change the path to the interpreter and to dynamically linked libraries. Thankfully the Nix package repository 'NixPkgs' is the largest and freshest out there\footnote{\url{https://repology.org/repositories/graphs}}, so as a typical user doing this is rarely needed.
Nixpkgs is a version-controlled repository on GitHub, so using older versions of packages even alongside newer ones, is fairly trivial as it simply requires fetching multiple revision of the repository.

This along with the previously mentioned features have allowed a greatly simplified process of not only running the newest version 6.7.1 of the xTB program, but also running the much older nvfortran compatible version 6.4.0 alongside it.
NixPkgs is also a collection of library functions, and the helper functions for making derivations called `mkDerivation` make it easy to define all the stages of packaging a program including unpacking, patching, building, checking, and installing the files.
With this, the whole pipeline of patching, compiling, running, and passing the data over to the Python validation tests can be achieved with a single shell command.

\begin{minted}[linenos=false]{bash}
> nix run .#cmp-impls
\end{minted}


This command takes the form '\verb|nix run <path to flake>#<output>|'. Path to flake refers to a file-tree whose root directory contains a file called 'flake.nix'. Nix flakes is an experimental but widely adopted feature, which provides a standard way to write Nix expressions and a way to manager their dependencies through a version-pinned lock file. The 'flake.nix' file follows a uniform naming schema for declaring inputs and outputs, where inputs are the dependencies, and outputs are Nix expressions to be exposed.
The new Nix command-line interface needed to interact with flakes is naturally also an experimental feature that has to be enabled explicitly. The run command instructs Nix to build and run the derivation 'cmp-impls', which is defined as an app in the flake outputs.

\newpage

\begin{minted}{nix}
  {
    inputs = {
      nixpkgs.url = "github:nixos/nixpkgs/nixos-unstable";
    };

    outputs = { self, nixpkgs, ... }: {
      apps."x86_64-linux" = let
        pkgs = nixpkgs.legacyPackages."x86_64-linux";
        ...
      in {
        "cmp-impls" = let
          python = (pkgs.python3.withPackages (python-pkgs: with python-pkgs; [
            numpy scipy cvxopt
          ]));
        in {
          type = "app";
          program = toString (pkgs.writeShellScript "cmp-impls" ''
            PYTHONPATH=${pkgs.lib.cleanSource ./xtb-python} exec ${python}/bin/python \
              ${./xtb-python/cmp_impls.py} ${xtb_test_data}
          '');
        };
      };
      ...
    };
  }
\end{minted}

Python is declared with the required packages and is then used in the app to call the \verb|cmp_impls.py| script. The script is called with the test data acquired from running the Fortran xTB program. This data comes from another derivation which executes patched versions of xTB and DFT-D4 on a C200 fullerene to get the relevant function arguments and results as binary files.

\begin{minted}{nix}
  xtb_test_data = builtins.derivation {
    name = "xtb-test-data";
    system = "x86_64-linux";
    builder = "${pkgs.bash}/bin/bash";
    src = ./xtb-python/data/C200.xyz;
    args = ["-c" ''
      PATH=$PATH:${pkgs.coreutils}/bin
      mkdir -p ./calls/{build_SDQH0,coordination_number,\
        dim_basis,dtrf2,electro,form_product,get_multiints,\
        h0scal,horizontal_shift,multipole_3d,newBasisset, olapp}
      ${xtb}/bin/xtb $src
      ${dftd4}/bin/dftd4 $src
      mv calls $out
    ''];
  };
\end{minted}

The directories for the binary files are created in advance as checking whether they exist when writing the binary files has a large overhead.
This derivation in turn uses derivations for xTB and DFT-D4. Luckily DFT-D4 is already in NixPkgs, but it still needs to be patched in order to extract the required data for validation. Thankfully the \verb|mkDerivation| function used in NixPkgs makes overriding and patching a package very straightforward. 

\begin{minted}{nix}
  dftd4 = (pkgs.dftd4.overrideAttrs (finalAttrs: previousAttrs: {
    src = pkgs.fetchFromGitHub {
      owner = "dftd4";
      repo = "dftd4";
      rev = "502d7c59bf88beec7c90a71c4ecf80029794bd5e";
      hash = "sha256-FEABtBAZK0xQ1P/Pbj5gUuvKf8/ZLITXaXYB+btAY/8=";
    };
    buildInputs = [ multicharge ] ++ previousAttrs.buildInputs;
    doCheck = false;
    patches = previousAttrs.patches ++ [
      ./nix/patches/dftd4/use_gfn2.patch
      ./nix/patches/dftd4/log_args_and_outputs.patch
    ];
  }));
\end{minted}

The version is bumped by overriding the source, and the multicharge project is added from NixPkgs and also bumped as a requirement of this newer version. Some of the tests were timing out, so they have been disabled by setting \verb|doCheck| to false. Lastly the patches are applied by providing the relevant patch files.


xTB and two of its dependencies, namely CPCM-X and numsa are not in NixPkgs and had to be packaged from scratch.

All the patches follow the structure below where the original function is prefixed with a 'g', such that the new wrapper function will be called instead. The wrapper function writes the function arguments to a binary file before calling the actual function and then finally writes the result to the same file.
Writing a file for each call to a function is a bit excessive and will produce a very large amount of files, so a threshold has been used to create an upperbound on the number of files that can be created for each function.

\begin{minted}[linenos=false]{diff}
+   logical :: hit_threshold
+   integer :: u
+   character(len=200) :: path
+
+   hit_threshold = testfile_path('electro', path)
+   if (.not.hit_threshold) then
+     open(newunit=u, file=trim(path), form='unformatted', access='stream')
+     write(u) nbf
+     write(u) size(H0), H0
+     write(u) size(P, 1), size(P, 2), P
...
+     if (allocated(ies%thirdOrder%atomicGam)) then
+       write(u) size(ies%thirdorder%atomicgam), ies%thirdorder%atomicgam
+     else
+       write(u) 0
+     end if
...
+     write(u) size(ies%jmat, 1), size(ies%jmat, 2), ies%jmat
+     write(u) size(ies%shift), ies%shift
+   end if
+
+   call gelectro(n,at,nbf,nshell,ies,H0,P,dq,dqsh,es,scc)
+
+   if (.not.hit_threshold) then
+     write(u) es
+     write(u) scc
+     close(u)
+   end if
\end{minted}

When all the data has been written, then the binary files are passed onto \verb|cmp-impls.py|, which is the test suite for comparing the Python reimplementation to the original Fortran code. 

\begin{minted}{python}
  def test_electro():
      fn_name = "electro"
      for i, file_path in enumerate(glob.glob(f'{directory}/{fn_name}/*.bin')):
          with open(file_path, 'rb') as f:
              def read_ints(n=1):
                  return np.fromfile(f, dtype=np.int32, count=n)

              nbf = read_ints(1)[0]
              H01 = read_ints(1)[0]
              H0 = np.fromfile(f, dtype=np.float64, count=H01)
              m, n = read_ints(2)
              P = np.fromfile(f, dtype=np.float64, count=m * n).reshape((n, m))
              ...
              atomicGam1 = read_ints(1)[0]
              atomicGam = None  if atomicGam1 == 0
                                else np.fromfile(f, dtype=np.float64, count=atomicGam1)
              ...
              es_res, scc_res = read_reals(2)
              es, scc = electro(nbf, H0, P, dq, dqsh, atomicGam, shellGam, jmat, shift)

              is_equal(es, es_res, "es", fn_name)
              is_equal(scc, scc_res, "scc", fn_name)

      print(f"matches! [{fn_name}]")
\end{minted}
