diff --git a/src/intgrad.f90 b/src/intgrad.f90
index 44f8f7e..ac1fdfd 100644
--- a/src/intgrad.f90
+++ b/src/intgrad.f90
@@ -22,6 +22,7 @@
 module xtb_intgrad
    use xtb_mctc_accuracy, only : wp
    use xtb_mctc_constants, only : pi
+   use utils
    implicit none
 
    integer, parameter :: maxl = 6
@@ -87,12 +88,18 @@ module xtb_intgrad
 
    integer, parameter, private :: itt(0:3) = [0,1,4,10]
 
+
+   interface olapp
+      module procedure olapp_scalar
+      module procedure olapp_array
+   end interface
+
 contains
 
 
 ! --------------------------------------------------------------[SAW1907]-
 !> calculates a partial overlap in one cartesian direction
-pure elemental function olapp(l,gama) result(s)
+pure elemental function golapp(l,gama) result(s)
    !$acc routine seq
    integer,intent(in) :: l
    real(wp),intent(in) :: gama
@@ -108,7 +115,47 @@ pure elemental function olapp(l,gama) result(s)
       gm=0.5_wp/gama
       s=gm**lh*dftr(lh)
    endif
-end function olapp
+end function golapp
+
+function olapp_array(l, gama) result(s)
+   integer,intent(in) :: l(:)
+   real(wp),intent(in) :: gama
+   real(wp) :: s(size(l))
+
+   integer :: u
+   character(len=200) :: path
+   call testfile_path('olapp', path)
+
+   open(newunit=u, file=trim(path), form='unformatted', access='stream')
+   write(u) size(l), l
+   write(u) gama
+
+   s = golapp(l, gama)
+
+   write(u) size(s), s
+   close(u)
+
+end function olapp_array
+
+function olapp_scalar(l, gama) result(s)
+   integer,intent(in) :: l
+   real(wp),intent(in) :: gama
+   real(wp) :: s
+
+   integer :: u
+   character(len=200) :: path
+   call testfile_path('olapp', path)
+
+   open(newunit=u, file=trim(path), form='unformatted', access='stream')
+   write(u) 1, [l]
+   write(u) gama
+
+   s = golapp(l, gama)
+
+   write(u) 1, [s]
+   close(u)
+
+end function olapp_scalar
 
 ! --------------------------------------------------------------[SAW1907]-
 !> returns center of product Gaussian from two Gaussians by GPT
@@ -141,7 +188,7 @@ pure subroutine build_kab(ra,alp,rb,bet,gama,kab)
 end subroutine build_kab
 
 ! --------------------------------------------------------------[SAW1801]-
-pure subroutine dtrf2(s,li,lj)
+pure subroutine gdtrf2(s,li,lj)
    use xtb_mctc_blas, only : mctc_gemm
    real(wp),intent(inout) :: s(6,6)
    integer, intent(in)    :: li,lj
@@ -228,6 +275,26 @@ pure subroutine dtrf2(s,li,lj)
    s(1:5,1:5) = s2(2:6,2:6)
    return
 
+end subroutine gdtrf2
+
+subroutine dtrf2(s,li,lj)
+   use xtb_mctc_blas, only : mctc_gemm
+   real(wp),intent(inout) :: s(6,6)
+   integer, intent(in)    :: li,lj
+
+   integer :: u
+   character(len=200) :: path
+   call testfile_path('dtrf2', path)
+
+   open(newunit=u, file=trim(path), form='unformatted', access='stream')
+   write(u) size(s, 1), size(s, 2), s
+   write(u) li
+   write(u) lj
+
+   call gdtrf2(s,li,lj)
+
+   write(u) size(s, 1), size(s, 2), s
+   close(u)
 end subroutine dtrf2
 
 ! --------------------------------------------------------------[SAW1801]-
@@ -354,7 +421,7 @@ pure subroutine prod3(a,b,d,la,lb)
 
 end subroutine prod3
 
-pure subroutine horizontal_shift(ae, l, cfs)
+pure subroutine ghorizontal_shift(ae, l, cfs)
    integer, intent(in) :: l
    real(wp), intent(in) :: ae
    real(wp), intent(inout) :: cfs(*)
@@ -377,9 +444,29 @@ pure subroutine horizontal_shift(ae, l, cfs)
       cfs(3)=cfs(3)+ 6*ae*ae*cfs(5)
       cfs(4)=cfs(4)+ 4*ae*cfs(5)
    end select
+end subroutine ghorizontal_shift
+
+subroutine horizontal_shift(ae, l, cfs)
+   integer, intent(in) :: l
+   real(wp), intent(in) :: ae
+   real(wp), intent(inout) :: cfs(:)
+
+   integer :: u
+   character(len=200) :: path
+   call testfile_path('horizontal_shift', path)
+
+   open(newunit=u, file=trim(path), form='unformatted', access='stream')
+   write(u) ae
+   write(u) l
+   write(u) size(cfs), cfs
+
+   call ghorizontal_shift(ae, l, cfs)
+
+   write(u) size(cfs), cfs
+   close(u)
 end subroutine horizontal_shift
 
-pure subroutine form_product(a, b, la, lb, d)
+pure subroutine gform_product(a, b, la, lb, d)
    integer, intent(in) :: la, lb
    real(wp), intent(in) :: a(*), b(*)
    real(wp), intent(inout) :: d(*)
@@ -468,10 +555,31 @@ pure subroutine form_product(a, b, la, lb, d)
    !       = <s> + <p> + <d> + <f> + <g> + <h> + <i> + <k> + <l>
    d(9)=a(5)*b(5)
 
-end subroutine form_product
+end subroutine gform_product
+
+subroutine form_product(a, b, la, lb, d)
+   integer, intent(in) :: la, lb
+   real(wp), intent(in) :: a(:), b(:)
+   real(wp), intent(inout) :: d(:)
+
+   integer :: u
+   character(len=200) :: path
+   call testfile_path('form_product', path)
 
+   open(newunit=u, file=trim(path), form='unformatted', access='stream')
+   write(u) la
+   write(u) lb
+   write(u) size(a), a
+   write(u) size(b), b
+   write(u) size(d), d
 
-pure subroutine overlap_3d(ri, rj, rp, ai, aj, li, lj, s1d, s3d)
+   call gform_product(a, b, la, lb, d)
+
+   write(u) size(d), d
+   close(u)
+end subroutine form_product
+
+subroutine overlap_3d(ri, rj, rp, ai, aj, li, lj, s1d, s3d)
    real(wp), intent(in) :: ri(3)
    real(wp), intent(in) :: rj(3)
    real(wp), intent(in) :: rp(3)
@@ -506,7 +614,7 @@ pure subroutine overlap_3d(ri, rj, rp, ai, aj, li, lj, s1d, s3d)
 
 end subroutine overlap_3d
 
-pure subroutine multipole_3d(ri, rj, rc, rp, ai, aj, li, lj, s1d, s3d)
+subroutine gmultipole_3d(ri, rj, rc, rp, ai, aj, li, lj, s1d, s3d)
    real(wp), intent(in) :: ri(3)
    real(wp), intent(in) :: rj(3)
    real(wp), intent(in) :: rp(3)
@@ -552,9 +660,41 @@ pure subroutine multipole_3d(ri, rj, rc, rp, ai, aj, li, lj, s1d, s3d)
    s3d( 9) = val(1, 2) * val(2, 1) * val(3, 2)
    s3d(10) = val(1, 1) * val(2, 2) * val(3, 2)
 
+end subroutine gmultipole_3d
+
+subroutine multipole_3d(ri, rj, rc, rp, ai, aj, li, lj, s1d, s3d)
+   real(wp), intent(in) :: ri(3)
+   real(wp), intent(in) :: rj(3)
+   real(wp), intent(in) :: rp(3)
+   real(wp), intent(in) :: rc(3)
+   real(wp), intent(in) :: ai
+   real(wp), intent(in) :: aj
+   integer, intent(in) :: li(3)
+   integer, intent(in) :: lj(3)
+   real(wp), intent(in) :: s1d(0:)
+   real(wp), intent(out) :: s3d(10)
+
+   integer :: u
+   character(len=200) :: path
+   call testfile_path('multipole_3d', path)
+
+   open(newunit=u, file=trim(path), form='unformatted', access='stream')
+   write(u) size(ri), ri
+   write(u) size(rj), rj
+   write(u) size(rc), rc
+   write(u) size(rp), rp
+   write(u) size(li), li
+   write(u) size(lj), lj
+   write(u) size(s1d), s1d
+   write(u) size(s3d), s3d
+
+   call gmultipole_3d(ri, rj, rc, rp, ai, aj, li, lj, s1d, s3d)
+
+   write(u) size(s3d), s3d
+   close(u)
 end subroutine multipole_3d
 
-pure subroutine overlap_grad_3d(ri, rj, rp, ai, aj, li, lj, s1d, s3d, ds3d)
+subroutine overlap_grad_3d(ri, rj, rp, ai, aj, li, lj, s1d, s3d, ds3d)
    real(wp), intent(in) :: ri(3)
    real(wp), intent(in) :: rj(3)
    real(wp), intent(in) :: rp(3)
@@ -604,7 +744,7 @@ pure subroutine overlap_grad_3d(ri, rj, rp, ai, aj, li, lj, s1d, s3d, ds3d)
 
 end subroutine overlap_grad_3d
 
-pure subroutine multipole_grad_3d(ri, rj, rc, rp, ai, aj, li, lj, s1d, s3d, ds3d)
+subroutine multipole_grad_3d(ri, rj, rc, rp, ai, aj, li, lj, s1d, s3d, ds3d)
    real(wp), intent(in) :: ri(3)
    real(wp), intent(in) :: rj(3)
    real(wp), intent(in) :: rc(3)
@@ -728,7 +868,7 @@ pure subroutine shiftintg(g,s,r)
 end subroutine shiftintg
 
 
-pure subroutine get_overlap(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point,intcut, &
+subroutine get_overlap(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point,intcut, &
       &                nprim,primcount,alp,cont,sint)
    integer, intent(in)  :: icao
    integer, intent(in)  :: jcao
@@ -799,7 +939,7 @@ pure subroutine get_overlap(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point,intcut
 
 end subroutine get_overlap
 
-pure subroutine get_grad_overlap(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point,intcut, &
+subroutine get_grad_overlap(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point,intcut, &
       &                     nprim,primcount,alp,cont,sdq,sdqg)
    integer, intent(in)  :: icao
    integer, intent(in)  :: jcao
@@ -872,8 +1012,7 @@ pure subroutine get_grad_overlap(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point,i
    enddo  ! ip : loop over i prims
 end subroutine get_grad_overlap
 
-
-pure subroutine get_multiints(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point, &
+subroutine gget_multiints(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point, &
       &                           intcut,nprim,primcount,alp,cont,ss,dd,qq)
    integer, intent(in)  :: icao
    integer, intent(in)  :: jcao
@@ -948,10 +1087,55 @@ pure subroutine get_multiints(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point, &
          enddo  ! mli : Cartesian component of i prims
       enddo ! jp : loop over j prims
    enddo  ! ip : loop over i prims
-end subroutine get_multiints
+end subroutine gget_multiints
 
+subroutine get_multiints(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point, &
+      &                           intcut,nprim,primcount,alp,cont,ss,dd,qq)
+   integer, intent(in)  :: icao
+   integer, intent(in)  :: jcao
+   integer, intent(in)  :: naoi
+   integer, intent(in)  :: naoj
+   integer, intent(in)  :: ishtyp
+   integer, intent(in)  :: jshtyp
+   real(wp),intent(in)  :: ri(3)
+   real(wp),intent(in)  :: rj(3)
+   real(wp),intent(in)  :: point(3)
+   real(wp),intent(in)  :: intcut
+   real(wp),intent(out) :: ss(:,:)
+   real(wp),intent(out) :: dd(:,:,:)
+   real(wp),intent(out) :: qq(:,:,:)
+
+   integer, intent(in)  :: nprim(:)
+   integer, intent(in)  :: primcount(:)
+   real(wp),intent(in)  :: alp(:)
+   real(wp),intent(in)  :: cont(:)
+
+   integer :: u
+   character(len=200) :: path
+
+   call testfile_path('get_multiints', path)
+
+   open(newunit=u, file=trim(path), form='unformatted', access='stream')
+   write(u) icao, jcao, naoi, naoj, ishtyp, jshtyp
+   write(u) ri
+   write(u) rj
+   write(u) point
+   write(u) intcut
+   write(u) size(nprim), nprim
+   write(u) size(primcount), primcount
+   write(u) size(alp), alp
+   write(u) size(cont), cont
+
+   call gget_multiints(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point,intcut,nprim,primcount,alp,cont,ss,dd,qq)
+
+   write(u) size(ss, 1), size(ss, 2), ss
+   write(u) size(dd, 1), size(dd, 2), size(dd, 3), dd
+   write(u) size(qq, 1), size(qq, 2), size(qq, 3), qq
+
+   close(u)
+end subroutine get_multiints
 
-pure subroutine get_grad_multiint(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj, &
+subroutine get_grad_multiint(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj, &
       &                           intcut,nprim,primcount,alp,cont,sdq,sdqg)
    integer, intent(in)  :: icao
    integer, intent(in)  :: jcao
diff --git a/src/meson.build b/src/meson.build
index ced9a9d..12ddc1d 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -158,4 +158,5 @@ srcs += files(
   'wrmo.f90',
   'xhelp.f90',
   'zmatpr.f90',
+  'utils.f90',
 )
diff --git a/src/utils.f90 b/src/utils.f90
new file mode 100644
index 0000000..5145879
--- /dev/null
+++ b/src/utils.f90
@@ -0,0 +1,52 @@
+module utils
+  implicit none
+  contains
+
+  subroutine random_uuid(uuid)
+      character(len=*), intent(out) :: uuid
+      character(len=16) :: hexchars
+      integer :: i, n
+      real :: r(1)
+      character(len=1) :: c
+
+      hexchars = '0123456789abcdef'
+      uuid = ''
+      do i = 1, 36
+          if (i == 9 .or. i == 14 .or. i == 19 .or. i == 24) then
+              uuid(i:i) = '-'
+          else
+              call random_number(r)
+              n = 1 + int(r(1) * 16.0)
+              uuid(i:i) = hexchars(n:n)
+          end if
+      end do
+  end subroutine
+
+  subroutine create_directory(dir_name)
+     character(len=*), intent(in) :: dir_name
+     character(len=255) :: command
+
+     ! Construct the command to create the directory
+     write(command, '("mkdir -p ", A)') trim(adjustl(dir_name))
+
+     ! Execute the command
+     call system(command)
+  end subroutine create_directory
+
+  subroutine testfile_path(fn_name, path)
+    character(len=*), intent(in)  :: fn_name
+    character(len=*), intent(out) :: path
+
+    character(len=36) :: uuid
+    character(len=100) :: filename, dir
+
+    call random_seed()
+    call random_uuid(uuid)
+    write(filename, '(A,A)') 'args_', uuid
+    dir = 'calls/' // trim(fn_name) // '/'
+    write(path, '(A,A,A)') trim(dir), trim(filename), ".bin"
+
+    call create_directory(trim(dir))
+  end subroutine
+
+end module utils
