diff --git a/src/intgrad.f90 b/src/intgrad.f90
index 44f8f7e..6670c21 100644
--- a/src/intgrad.f90
+++ b/src/intgrad.f90
@@ -22,6 +22,7 @@
 module xtb_intgrad
    use xtb_mctc_accuracy, only : wp
    use xtb_mctc_constants, only : pi
+   use utils
    implicit none
 
    integer, parameter :: maxl = 6
@@ -141,10 +142,12 @@ pure subroutine build_kab(ra,alp,rb,bet,gama,kab)
 end subroutine build_kab
 
 ! --------------------------------------------------------------[SAW1801]-
-pure subroutine dtrf2(s,li,lj)
+! pure
+subroutine dtrf2(s,li,lj)
    use xtb_mctc_blas, only : mctc_gemm
    real(wp),intent(inout) :: s(6,6)
    integer, intent(in)    :: li,lj
+
    ! CAO-AO transformation
    real(wp), parameter :: trafo(6,6) = reshape((/ & ! copied from scf.f, simplyfied
       ! --- dS
@@ -167,8 +170,21 @@ pure subroutine dtrf2(s,li,lj)
    real(wp) s2(6,6),sspher,dum(6,6)
    integer ii,jj,m,n
 
+   integer :: u
+   character(len=200) :: path
+   call testfile_path('dtrf2', path)
+
+   open(newunit=u, file=trim(path), form='unformatted', access='stream')
+   write(u) size(s, 1), size(s, 2), s
+   write(u) li
+   write(u) lj
+
    !     transformation not needed for pure s/p overlap -> do nothing
-   if (li.lt.2.and.lj.lt.2) return
+   if (li.lt.2.and.lj.lt.2) then
+     write(u) size(s, 1), size(s, 2), s
+     close(u)
+     return
+   endif
 
    ! --- means li.ge.2.or.lj.ge.2, so one of them is a d-shell
    !     assuming its on jat ... a wild guess
@@ -182,6 +198,9 @@ pure subroutine dtrf2(s,li,lj)
          s2(jj,1)=sspher
       enddo
       s(1:5,1) = s2(2:6,1)
+
+      write(u) size(s, 1), size(s, 2), s
+      close(u)
       return
    case(1) ! p-d
       do ii=1,3
@@ -194,6 +213,9 @@ pure subroutine dtrf2(s,li,lj)
          enddo
          s(1:5,ii) = s2(2:6,ii)
       enddo
+
+      write(u) size(s, 1), size(s, 2), s
+      close(u)
       return
    end select
    !     wasn't there, then try iat ...
@@ -207,6 +229,9 @@ pure subroutine dtrf2(s,li,lj)
          s2(1,jj)=sspher
       enddo
       s(1,1:5) = s2(1,2:6)
+
+      write(u) size(s, 1), size(s, 2), s
+      close(u)
       return
    case(1) ! d-p
       do ii=1,3
@@ -219,6 +244,9 @@ pure subroutine dtrf2(s,li,lj)
          enddo
          s(ii,1:5) = s2(ii,2:6)
       enddo
+
+      write(u) size(s, 1), size(s, 2), s
+      close(u)
       return
    end select
    !     if not returned up to here -> d-d
@@ -226,6 +254,9 @@ pure subroutine dtrf2(s,li,lj)
    CALL mctc_gemm(trafo, s, dum, transa='T')
    CALL mctc_gemm(dum, trafo, s2, transb='N')
    s(1:5,1:5) = s2(2:6,2:6)
+
+   write(u) size(s, 1), size(s, 2), s
+   close(u)
    return
 
 end subroutine dtrf2
@@ -354,11 +385,23 @@ pure subroutine prod3(a,b,d,la,lb)
 
 end subroutine prod3
 
-pure subroutine horizontal_shift(ae, l, cfs)
+! pure
+subroutine horizontal_shift(ae, l, cfs)
    integer, intent(in) :: l
    real(wp), intent(in) :: ae
-   real(wp), intent(inout) :: cfs(*)
+   real(wp), intent(inout) :: cfs(:)
    integer :: i
+
+   integer :: u
+   character(len=200) :: path
+   call testfile_path('horizontal_shift', path)
+
+   open(newunit=u, file=trim(path), form='unformatted', access='stream')
+   write(u) ae
+   write(u) l
+   write(u) size(cfs), cfs
+
+
    select case(l)
    case(0) ! s
       continue
@@ -377,26 +420,57 @@ pure subroutine horizontal_shift(ae, l, cfs)
       cfs(3)=cfs(3)+ 6*ae*ae*cfs(5)
       cfs(4)=cfs(4)+ 4*ae*cfs(5)
    end select
+
+
+   write(u) size(cfs), cfs
+   close(u)
+
 end subroutine horizontal_shift
 
-pure subroutine form_product(a, b, la, lb, d)
+! pure
+subroutine form_product(a, b, la, lb, d)
    integer, intent(in) :: la, lb
-   real(wp), intent(in) :: a(*), b(*)
-   real(wp), intent(inout) :: d(*)
+   real(wp), intent(in) :: a(:), b(:)
+   real(wp), intent(inout) :: d(:)
    integer :: i
+
+
+   integer :: u
+   character(len=200) :: path
+   call testfile_path('form_product', path)
+
+   open(newunit=u, file=trim(path), form='unformatted', access='stream')
+   write(u) la
+   write(u) lb
+   write(u) size(a), a
+   write(u) size(b), b
+   write(u) size(d), d
+
+
    if(la.ge.4.or.lb.ge.4) goto 40
    if(la.ge.3.or.lb.ge.3) goto 30
    if(la.ge.2.or.lb.ge.2) goto 20
    ! <s|s> = <s>
    d(1)=a(1)*b(1)
-   if(la.eq.0.and.lb.eq.0) return
+   if(la.eq.0.and.lb.eq.0) then
+     write(u) size(d), d
+     close(u)
+     return
+   endif
    ! <s|p> = <s|*(|s>+|p>)
    !       = <s> + <p>
    d(2)=a(1)*b(2)+a(2)*b(1)
-   if(la.eq.0.or.lb.eq.0) return
+   if(la.eq.0.or.lb.eq.0) then
+     write(u) size(d), d
+     close(u)
+     return
+   endif
    ! <p|p> = (<s|+<p|)*(|s>+|p>)
    !       = <s> + <p> + <d>
    d(3)=a(2)*b(2)
+
+   write(u) size(d), d
+   close(u)
    return
 20 continue
    ! <s|d> = <s|*(|s>+|p>+|d>)
@@ -404,15 +478,26 @@ pure subroutine form_product(a, b, la, lb, d)
    d(1)=a(1)*b(1)
    d(2)=a(1)*b(2)+a(2)*b(1)
    d(3)=a(1)*b(3)+a(3)*b(1)
-   if(la.eq.0.or.lb.eq.0) return
+   if(la.eq.0.or.lb.eq.0) then
+     write(u) size(d), d
+     close(u)
+     return
+   endif
    ! <p|d> = (<s|+<p|)*(|s>+|p>+|d>)
    !       = <s> + <p> + <d> + <f>
    d(3)=d(3)+a(2)*b(2)
    d(4)=a(2)*b(3)+a(3)*b(2)
-   if(la.le.1.or.lb.le.1) return
+   if(la.le.1.or.lb.le.1) then
+     write(u) size(d), d
+     close(u)
+     return
+   endif
    ! <d|d> = (<s|+<p|+<d|)*(|s>+|p>+|d>)
    !       = <s> + <p> + <d> + <f> + <g>
    d(5)=a(3)*b(3)
+
+   write(u) size(d), d
+   close(u)
    return
 30 continue
    ! <s|f> = <s|*(|s>+|p>+|d>+|f>)
@@ -421,21 +506,36 @@ pure subroutine form_product(a, b, la, lb, d)
    d(2)=a(1)*b(2)+a(2)*b(1)
    d(3)=a(1)*b(3)+a(3)*b(1)
    d(4)=a(1)*b(4)+a(4)*b(1)
-   if(la.eq.0.or.lb.eq.0) return
+   if(la.eq.0.or.lb.eq.0) then
+     write(u) size(d), d
+     close(u)
+     return
+   endif
    ! <p|f> = (<s|+<p|)*(|s>+|p>+|d>+|f>)
    !       = <s> + <p> + <d> + <f> + <g>
    d(3)=d(3)+a(2)*b(2)
    d(4)=d(4)+a(2)*b(3)+a(3)*b(2)
    d(5)=a(2)*b(4)+a(4)*b(2)
-   if(la.le.1.or.lb.le.1) return
+   if(la.le.1.or.lb.le.1) then
+     write(u) size(d), d
+     close(u)
+     return
+   endif
    ! <d|f> = (<s|+<p|+<d|)*(|s>+|p>+|d>+|f>)
    !       = <s> + <p> + <d> + <f> + <g> + <h>
    d(5)=d(5)+a(3)*b(3)
    d(6)=a(3)*b(4)+a(4)*b(3)
-   if(la.le.2.or.lb.le.2) return
+   if(la.le.2.or.lb.le.2) then
+     write(u) size(d), d
+     close(u)
+     return
+   endif
    ! <f|f> = (<s|+<p|+<d|+<f|)*(|s>+|p>+|d>+|f>)
    !       = <s> + <p> + <d> + <f> + <g> + <h> + <i>
    d(7)=a(4)*b(4)
+
+   write(u) size(d), d
+   close(u)
    return
 40 continue
    ! <s|g> = <s|*(|s>+|p>+|d>+|f>+|g>)
@@ -445,33 +545,53 @@ pure subroutine form_product(a, b, la, lb, d)
    d(3)=a(1)*b(3)+a(3)*b(1)
    d(4)=a(1)*b(4)+a(4)*b(1)
    d(5)=a(1)*b(5)+a(5)*b(1)
-   if(la.eq.0.or.lb.eq.0) return
+   if(la.eq.0.or.lb.eq.0) then
+     write(u) size(d), d
+     close(u)
+     return
+   endif
    ! <p|g> = (<s|+<p|)*(|s>+|p>+|d>+|f>+|g>)
    !       = <s> + <p> + <d> + <f> + <g> + <h>
    d(3)=d(3)+a(2)*b(2)
    d(4)=d(4)+a(2)*b(3)+a(3)*b(2)
    d(5)=d(5)+a(2)*b(4)+a(4)*b(2)
    d(6)=a(2)*b(5)+a(5)*b(2)
-   if(la.le.1.or.lb.le.1) return
+   if(la.le.1.or.lb.le.1) then
+     write(u) size(d), d
+     close(u)
+     return
+   endif
    ! <d|g> = (<s|+<p|+<d|)*(|s>+|p>+|d>+|f>+|g>)
    !       = <s> + <p> + <d> + <f> + <g> + <h> + <i>
    d(5)=d(5)+a(3)*b(3)
    d(6)=d(5)+a(3)*b(4)+a(4)*b(3)
    d(7)=a(3)*b(5)+a(5)*b(3)
-   if(la.le.2.or.lb.le.2) return
+   if(la.le.2.or.lb.le.2) then
+     write(u) size(d), d
+     close(u)
+     return
+   endif
    ! <f|g> = (<s|+<p|+<d|+<f|)*(|s>+|p>+|d>+|f>+|g>)
    !       = <s> + <p> + <d> + <f> + <g> + <h> + <i> + <k>
    d(7)=d(7)+a(4)*b(4)
    d(8)=a(4)*b(5)+a(5)*b(4)
-   if(la.le.3.or.lb.le.3) return
+   if(la.le.3.or.lb.le.3) then
+     write(u) size(d), d
+     close(u)
+     return
+   endif
    ! <g|g> = (<s|+<p|+<d|+<f|+<g|)*(|s>+|p>+|d>+|f>+|g>)
    !       = <s> + <p> + <d> + <f> + <g> + <h> + <i> + <k> + <l>
    d(9)=a(5)*b(5)
 
+   write(u) size(d), d
+   close(u)
+
 end subroutine form_product
 
 
-pure subroutine overlap_3d(ri, rj, rp, ai, aj, li, lj, s1d, s3d)
+! pure
+subroutine overlap_3d(ri, rj, rp, ai, aj, li, lj, s1d, s3d)
    real(wp), intent(in) :: ri(3)
    real(wp), intent(in) :: rj(3)
    real(wp), intent(in) :: rp(3)
@@ -506,7 +626,8 @@ pure subroutine overlap_3d(ri, rj, rp, ai, aj, li, lj, s1d, s3d)
 
 end subroutine overlap_3d
 
-pure subroutine multipole_3d(ri, rj, rc, rp, ai, aj, li, lj, s1d, s3d)
+! pure
+subroutine multipole_3d(ri, rj, rc, rp, ai, aj, li, lj, s1d, s3d)
    real(wp), intent(in) :: ri(3)
    real(wp), intent(in) :: rj(3)
    real(wp), intent(in) :: rp(3)
@@ -521,6 +642,22 @@ pure subroutine multipole_3d(ri, rj, rc, rp, ai, aj, li, lj, s1d, s3d)
    integer :: k, l
    real(wp) :: vi(0:maxl), vj(0:maxl), vv(0:maxl2), val(3, 3), rpc
 
+
+   integer :: u
+   character(len=200) :: path
+   call testfile_path('multipole_3d', path)
+
+   open(newunit=u, file=trim(path), form='unformatted', access='stream')
+   write(u) size(ri), ri
+   write(u) size(rj), rj
+   write(u) size(rc), rc
+   write(u) size(rp), rp
+   write(u) size(li), li
+   write(u) size(lj), lj
+   write(u) size(s1d), s1d
+   write(u) size(s3d), s3d
+
+
    val(:, :) = 0.0_wp
 
    do k = 1, 3
@@ -552,9 +689,14 @@ pure subroutine multipole_3d(ri, rj, rc, rp, ai, aj, li, lj, s1d, s3d)
    s3d( 9) = val(1, 2) * val(2, 1) * val(3, 2)
    s3d(10) = val(1, 1) * val(2, 2) * val(3, 2)
 
+
+   write(u) size(s3d), s3d
+   close(u)
+
 end subroutine multipole_3d
 
-pure subroutine overlap_grad_3d(ri, rj, rp, ai, aj, li, lj, s1d, s3d, ds3d)
+! pure
+subroutine overlap_grad_3d(ri, rj, rp, ai, aj, li, lj, s1d, s3d, ds3d)
    real(wp), intent(in) :: ri(3)
    real(wp), intent(in) :: rj(3)
    real(wp), intent(in) :: rp(3)
@@ -604,7 +746,8 @@ pure subroutine overlap_grad_3d(ri, rj, rp, ai, aj, li, lj, s1d, s3d, ds3d)
 
 end subroutine overlap_grad_3d
 
-pure subroutine multipole_grad_3d(ri, rj, rc, rp, ai, aj, li, lj, s1d, s3d, ds3d)
+! pure
+subroutine multipole_grad_3d(ri, rj, rc, rp, ai, aj, li, lj, s1d, s3d, ds3d)
    real(wp), intent(in) :: ri(3)
    real(wp), intent(in) :: rj(3)
    real(wp), intent(in) :: rc(3)
@@ -728,7 +871,8 @@ pure subroutine shiftintg(g,s,r)
 end subroutine shiftintg
 
 
-pure subroutine get_overlap(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point,intcut, &
+! pure
+subroutine get_overlap(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point,intcut, &
       &                nprim,primcount,alp,cont,sint)
    integer, intent(in)  :: icao
    integer, intent(in)  :: jcao
@@ -799,7 +943,8 @@ pure subroutine get_overlap(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point,intcut
 
 end subroutine get_overlap
 
-pure subroutine get_grad_overlap(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point,intcut, &
+! pure
+subroutine get_grad_overlap(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point,intcut, &
       &                     nprim,primcount,alp,cont,sdq,sdqg)
    integer, intent(in)  :: icao
    integer, intent(in)  :: jcao
@@ -872,8 +1017,8 @@ pure subroutine get_grad_overlap(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point,i
    enddo  ! ip : loop over i prims
 end subroutine get_grad_overlap
 
-
-pure subroutine get_multiints(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point, &
+! pure
+subroutine get_multiints(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point, &
       &                           intcut,nprim,primcount,alp,cont,ss,dd,qq)
    integer, intent(in)  :: icao
    integer, intent(in)  :: jcao
@@ -894,13 +1039,29 @@ pure subroutine get_multiints(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point, &
    real(wp),intent(in)  :: alp(:)
    real(wp),intent(in)  :: cont(:)
 
-   integer  :: ip,iprim,mli,jp,jprim,mlj,k,iptyp,jptyp
+   integer  :: ip,iprim,mli,jp,jprim,mlj,k,iptyp,jptyp,i,j
    real(wp) :: rij(3),rp(3),rij2,alpi,alpj,ci,cj,cc,kab,t(0:8)
    real(wp) :: ab,est,saw(10),sawg(3,10)
 
    real(wp),parameter :: max_r2 = 2000.0_wp
    real(wp),parameter :: sqrtpi = sqrt(pi)
 
+   integer :: u
+   character(len=200) :: path
+
+   call testfile_path('get_multiints', path)
+
+   open(newunit=u, file=trim(path), form='unformatted', access='stream')
+   write(u) icao, jcao, naoi, naoj, ishtyp, jshtyp
+   write(u) ri
+   write(u) rj
+   write(u) point
+   write(u) intcut
+   write(u) size(nprim), nprim
+   write(u) size(primcount), primcount
+   write(u) size(alp), alp
+   write(u) size(cont), cont
+
    ss = 0.0_wp
    dd = 0.0_wp
    qq = 0.0_wp
@@ -910,7 +1071,14 @@ pure subroutine get_multiints(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point, &
    rij = ri - rj
    rij2 = rij(1)**2 + rij(2)**2 + rij(3)**2
 
-   if(rij2.gt.max_r2) return
+   if(rij2.gt.max_r2) then
+     write(u) size(ss, 1), size(ss, 2), ss
+     write(u) size(dd, 1), size(dd, 2), size(dd, 3), dd
+     write(u) size(qq, 1), size(qq, 2), size(qq, 3), qq
+
+     close(u)
+     return
+   endif
 
    ! we go through the primitives (because the screening is the same for all of them)
    do ip = 1,nprim(icao+1)
@@ -948,10 +1116,17 @@ pure subroutine get_multiints(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point, &
          enddo  ! mli : Cartesian component of i prims
       enddo ! jp : loop over j prims
    enddo  ! ip : loop over i prims
+
+   write(u) size(ss, 1), size(ss, 2), ss
+   write(u) size(dd, 1), size(dd, 2), size(dd, 3), dd
+   write(u) size(qq, 1), size(qq, 2), size(qq, 3), qq
+
+   close(u)
 end subroutine get_multiints
 
 
-pure subroutine get_grad_multiint(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj, &
+! pure
+subroutine get_grad_multiint(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj, &
       &                           intcut,nprim,primcount,alp,cont,sdq,sdqg)
    integer, intent(in)  :: icao
    integer, intent(in)  :: jcao
diff --git a/src/meson.build b/src/meson.build
index ced9a9d..12ddc1d 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -158,4 +158,5 @@ srcs += files(
   'wrmo.f90',
   'xhelp.f90',
   'zmatpr.f90',
+  'utils.f90',
 )
diff --git a/src/utils.f90 b/src/utils.f90
new file mode 100644
index 0000000..5145879
--- /dev/null
+++ b/src/utils.f90
@@ -0,0 +1,52 @@
+module utils
+  implicit none
+  contains
+
+  subroutine random_uuid(uuid)
+      character(len=*), intent(out) :: uuid
+      character(len=16) :: hexchars
+      integer :: i, n
+      real :: r(1)
+      character(len=1) :: c
+
+      hexchars = '0123456789abcdef'
+      uuid = ''
+      do i = 1, 36
+          if (i == 9 .or. i == 14 .or. i == 19 .or. i == 24) then
+              uuid(i:i) = '-'
+          else
+              call random_number(r)
+              n = 1 + int(r(1) * 16.0)
+              uuid(i:i) = hexchars(n:n)
+          end if
+      end do
+  end subroutine
+
+  subroutine create_directory(dir_name)
+     character(len=*), intent(in) :: dir_name
+     character(len=255) :: command
+
+     ! Construct the command to create the directory
+     write(command, '("mkdir -p ", A)') trim(adjustl(dir_name))
+
+     ! Execute the command
+     call system(command)
+  end subroutine create_directory
+
+  subroutine testfile_path(fn_name, path)
+    character(len=*), intent(in)  :: fn_name
+    character(len=*), intent(out) :: path
+
+    character(len=36) :: uuid
+    character(len=100) :: filename, dir
+
+    call random_seed()
+    call random_uuid(uuid)
+    write(filename, '(A,A)') 'args_', uuid
+    dir = 'calls/' // trim(fn_name) // '/'
+    write(path, '(A,A,A)') trim(dir), trim(filename), ".bin"
+
+    call create_directory(trim(dir))
+  end subroutine
+
+end module utils
