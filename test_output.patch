diff --git a/src/intgrad.f90 b/src/intgrad.f90
index 44f8f7e..10ee35b 100644
--- a/src/intgrad.f90
+++ b/src/intgrad.f90
@@ -22,6 +22,7 @@
 module xtb_intgrad
    use xtb_mctc_accuracy, only : wp
    use xtb_mctc_constants, only : pi
+   use utils
    implicit none
 
    integer, parameter :: maxl = 6
@@ -87,12 +88,18 @@ module xtb_intgrad
 
    integer, parameter, private :: itt(0:3) = [0,1,4,10]
 
+
+   interface olapp
+      module procedure olapp_scalar
+      module procedure olapp_array
+   end interface
+
 contains
 
 
 ! --------------------------------------------------------------[SAW1907]-
 !> calculates a partial overlap in one cartesian direction
-pure elemental function olapp(l,gama) result(s)
+pure elemental function golapp(l,gama) result(s)
    !$acc routine seq
    integer,intent(in) :: l
    real(wp),intent(in) :: gama
@@ -108,7 +115,55 @@ pure elemental function olapp(l,gama) result(s)
       gm=0.5_wp/gama
       s=gm**lh*dftr(lh)
    endif
-end function olapp
+end function golapp
+
+function olapp_array(l, gama) result(s)
+   integer,intent(in) :: l(:)
+   real(wp),intent(in) :: gama
+   real(wp) :: s(size(l))
+
+   logical :: exists
+   integer :: u
+   character(len=200) :: path
+
+   exists = testfile_path('olapp', path)
+   if (.not.exists) then
+     open(newunit=u, file=trim(path), form='unformatted', access='stream')
+     write(u) size(l), l
+     write(u) gama
+   end if
+
+   s = golapp(l, gama)
+
+   if (.not.exists) then
+     write(u) size(s), s
+     close(u)
+   end if
+end function olapp_array
+
+function olapp_scalar(l, gama) result(s)
+   integer,intent(in) :: l
+   real(wp),intent(in) :: gama
+   real(wp) :: s
+
+   logical :: exists
+   integer :: u
+   character(len=200) :: path
+
+   exists = testfile_path('olapp', path)
+   if (.not.exists) then
+     open(newunit=u, file=trim(path), form='unformatted', access='stream')
+     write(u) 1, [l]
+     write(u) gama
+   end if
+
+   s = golapp(l, gama)
+
+   if (.not.exists) then
+     write(u) 1, [s]
+     close(u)
+   end if
+end function olapp_scalar
 
 ! --------------------------------------------------------------[SAW1907]-
 !> returns center of product Gaussian from two Gaussians by GPT
@@ -141,7 +196,7 @@ pure subroutine build_kab(ra,alp,rb,bet,gama,kab)
 end subroutine build_kab
 
 ! --------------------------------------------------------------[SAW1801]-
-pure subroutine dtrf2(s,li,lj)
+pure subroutine gdtrf2(s,li,lj)
    use xtb_mctc_blas, only : mctc_gemm
    real(wp),intent(inout) :: s(6,6)
    integer, intent(in)    :: li,lj
@@ -228,6 +283,31 @@ pure subroutine dtrf2(s,li,lj)
    s(1:5,1:5) = s2(2:6,2:6)
    return
 
+end subroutine gdtrf2
+
+subroutine dtrf2(s,li,lj)
+   use xtb_mctc_blas, only : mctc_gemm
+   real(wp),intent(inout) :: s(6,6)
+   integer, intent(in)    :: li,lj
+
+   logical :: exists
+   integer :: u
+   character(len=200) :: path
+
+   exists = testfile_path('dtrf2', path)
+   if (.not.exists) then
+     open(newunit=u, file=trim(path), form='unformatted', access='stream')
+     write(u) size(s, 1), size(s, 2), s
+     write(u) li
+     write(u) lj
+   end if
+
+   call gdtrf2(s,li,lj)
+
+   if (.not.exists) then
+     write(u) size(s, 1), size(s, 2), s
+     close(u)
+   end if
 end subroutine dtrf2
 
 ! --------------------------------------------------------------[SAW1801]-
@@ -354,7 +434,7 @@ pure subroutine prod3(a,b,d,la,lb)
 
 end subroutine prod3
 
-pure subroutine horizontal_shift(ae, l, cfs)
+pure subroutine ghorizontal_shift(ae, l, cfs)
    integer, intent(in) :: l
    real(wp), intent(in) :: ae
    real(wp), intent(inout) :: cfs(*)
@@ -377,9 +457,34 @@ pure subroutine horizontal_shift(ae, l, cfs)
       cfs(3)=cfs(3)+ 6*ae*ae*cfs(5)
       cfs(4)=cfs(4)+ 4*ae*cfs(5)
    end select
+end subroutine ghorizontal_shift
+
+subroutine horizontal_shift(ae, l, cfs)
+   integer, intent(in) :: l
+   real(wp), intent(in) :: ae
+   real(wp), intent(inout) :: cfs(:)
+
+   logical :: exists
+   integer :: u
+   character(len=200) :: path
+
+   exists = testfile_path('horizontal_shift', path)
+   if (.not.exists) then
+     open(newunit=u, file=trim(path), form='unformatted', access='stream')
+     write(u) ae
+     write(u) l
+     write(u) size(cfs), cfs
+   end if
+
+   call ghorizontal_shift(ae, l, cfs)
+
+   if (.not.exists) then
+     write(u) size(cfs), cfs
+     close(u)
+   end if
 end subroutine horizontal_shift
 
-pure subroutine form_product(a, b, la, lb, d)
+pure subroutine gform_product(a, b, la, lb, d)
    integer, intent(in) :: la, lb
    real(wp), intent(in) :: a(*), b(*)
    real(wp), intent(inout) :: d(*)
@@ -468,10 +573,36 @@ pure subroutine form_product(a, b, la, lb, d)
    !       = <s> + <p> + <d> + <f> + <g> + <h> + <i> + <k> + <l>
    d(9)=a(5)*b(5)
 
-end subroutine form_product
+end subroutine gform_product
 
+subroutine form_product(a, b, la, lb, d)
+   integer, intent(in) :: la, lb
+   real(wp), intent(in) :: a(:), b(:)
+   real(wp), intent(inout) :: d(:)
+
+   logical :: exists
+   integer :: u
+   character(len=200) :: path
+
+   exists = testfile_path('form_product', path)
+   if (.not.exists) then
+     open(newunit=u, file=trim(path), form='unformatted', access='stream')
+     write(u) la
+     write(u) lb
+     write(u) size(a), a
+     write(u) size(b), b
+     write(u) size(d), d
+   end if
+
+   call gform_product(a, b, la, lb, d)
+
+   if (.not.exists) then
+     write(u) size(d), d
+     close(u)
+   end if
+end subroutine form_product
 
-pure subroutine overlap_3d(ri, rj, rp, ai, aj, li, lj, s1d, s3d)
+subroutine overlap_3d(ri, rj, rp, ai, aj, li, lj, s1d, s3d)
    real(wp), intent(in) :: ri(3)
    real(wp), intent(in) :: rj(3)
    real(wp), intent(in) :: rp(3)
@@ -506,7 +637,7 @@ pure subroutine overlap_3d(ri, rj, rp, ai, aj, li, lj, s1d, s3d)
 
 end subroutine overlap_3d
 
-pure subroutine multipole_3d(ri, rj, rc, rp, ai, aj, li, lj, s1d, s3d)
+subroutine gmultipole_3d(ri, rj, rc, rp, ai, aj, li, lj, s1d, s3d)
    real(wp), intent(in) :: ri(3)
    real(wp), intent(in) :: rj(3)
    real(wp), intent(in) :: rp(3)
@@ -552,9 +683,46 @@ pure subroutine multipole_3d(ri, rj, rc, rp, ai, aj, li, lj, s1d, s3d)
    s3d( 9) = val(1, 2) * val(2, 1) * val(3, 2)
    s3d(10) = val(1, 1) * val(2, 2) * val(3, 2)
 
+end subroutine gmultipole_3d
+
+subroutine multipole_3d(ri, rj, rc, rp, ai, aj, li, lj, s1d, s3d)
+   real(wp), intent(in) :: ri(3)
+   real(wp), intent(in) :: rj(3)
+   real(wp), intent(in) :: rp(3)
+   real(wp), intent(in) :: rc(3)
+   real(wp), intent(in) :: ai
+   real(wp), intent(in) :: aj
+   integer, intent(in) :: li(3)
+   integer, intent(in) :: lj(3)
+   real(wp), intent(in) :: s1d(0:)
+   real(wp), intent(out) :: s3d(10)
+
+   logical :: exists
+   integer :: u
+   character(len=200) :: path
+
+   exists = testfile_path('multipole_3d', path)
+   if (.not.exists) then
+     open(newunit=u, file=trim(path), form='unformatted', access='stream')
+     write(u) size(ri), ri
+     write(u) size(rj), rj
+     write(u) size(rc), rc
+     write(u) size(rp), rp
+     write(u) size(li), li
+     write(u) size(lj), lj
+     write(u) size(s1d), s1d
+     write(u) size(s3d), s3d
+   end if
+
+   call gmultipole_3d(ri, rj, rc, rp, ai, aj, li, lj, s1d, s3d)
+
+   if (.not.exists) then
+     write(u) size(s3d), s3d
+     close(u)
+   end if
 end subroutine multipole_3d
 
-pure subroutine overlap_grad_3d(ri, rj, rp, ai, aj, li, lj, s1d, s3d, ds3d)
+subroutine overlap_grad_3d(ri, rj, rp, ai, aj, li, lj, s1d, s3d, ds3d)
    real(wp), intent(in) :: ri(3)
    real(wp), intent(in) :: rj(3)
    real(wp), intent(in) :: rp(3)
@@ -604,7 +772,7 @@ pure subroutine overlap_grad_3d(ri, rj, rp, ai, aj, li, lj, s1d, s3d, ds3d)
 
 end subroutine overlap_grad_3d
 
-pure subroutine multipole_grad_3d(ri, rj, rc, rp, ai, aj, li, lj, s1d, s3d, ds3d)
+subroutine multipole_grad_3d(ri, rj, rc, rp, ai, aj, li, lj, s1d, s3d, ds3d)
    real(wp), intent(in) :: ri(3)
    real(wp), intent(in) :: rj(3)
    real(wp), intent(in) :: rc(3)
@@ -728,7 +896,7 @@ pure subroutine shiftintg(g,s,r)
 end subroutine shiftintg
 
 
-pure subroutine get_overlap(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point,intcut, &
+subroutine get_overlap(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point,intcut, &
       &                nprim,primcount,alp,cont,sint)
    integer, intent(in)  :: icao
    integer, intent(in)  :: jcao
@@ -799,7 +967,7 @@ pure subroutine get_overlap(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point,intcut
 
 end subroutine get_overlap
 
-pure subroutine get_grad_overlap(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point,intcut, &
+subroutine get_grad_overlap(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point,intcut, &
       &                     nprim,primcount,alp,cont,sdq,sdqg)
    integer, intent(in)  :: icao
    integer, intent(in)  :: jcao
@@ -872,8 +1040,7 @@ pure subroutine get_grad_overlap(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point,i
    enddo  ! ip : loop over i prims
 end subroutine get_grad_overlap
 
-
-pure subroutine get_multiints(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point, &
+subroutine gget_multiints(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point, &
       &                           intcut,nprim,primcount,alp,cont,ss,dd,qq)
    integer, intent(in)  :: icao
    integer, intent(in)  :: jcao
@@ -948,10 +1115,59 @@ pure subroutine get_multiints(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point, &
          enddo  ! mli : Cartesian component of i prims
       enddo ! jp : loop over j prims
    enddo  ! ip : loop over i prims
-end subroutine get_multiints
+end subroutine gget_multiints
+
+subroutine get_multiints(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point, &
+      &                           intcut,nprim,primcount,alp,cont,ss,dd,qq)
+   integer, intent(in)  :: icao
+   integer, intent(in)  :: jcao
+   integer, intent(in)  :: naoi
+   integer, intent(in)  :: naoj
+   integer, intent(in)  :: ishtyp
+   integer, intent(in)  :: jshtyp
+   real(wp),intent(in)  :: ri(3)
+   real(wp),intent(in)  :: rj(3)
+   real(wp),intent(in)  :: point(3)
+   real(wp),intent(in)  :: intcut
+   real(wp),intent(out) :: ss(:,:)
+   real(wp),intent(out) :: dd(:,:,:)
+   real(wp),intent(out) :: qq(:,:,:)
+
+   integer, intent(in)  :: nprim(:)
+   integer, intent(in)  :: primcount(:)
+   real(wp),intent(in)  :: alp(:)
+   real(wp),intent(in)  :: cont(:)
 
+   logical :: exists
+   integer :: u
+   character(len=200) :: path
+
+   exists = testfile_path('get_multiints', path)
+   if (.not.exists) then
+     open(newunit=u, file=trim(path), form='unformatted', access='stream')
+     write(u) icao, jcao, naoi, naoj, ishtyp, jshtyp
+     write(u) ri
+     write(u) rj
+     write(u) point
+     write(u) intcut
+     write(u) size(nprim), nprim
+     write(u) size(primcount), primcount
+     write(u) size(alp), alp
+     write(u) size(cont), cont
+   end if
+
+   call gget_multiints(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj,point,intcut,nprim,primcount,alp,cont,ss,dd,qq)
+
+   if (.not.exists) then
+     write(u) size(ss, 1), size(ss, 2), ss
+     write(u) size(dd, 1), size(dd, 2), size(dd, 3), dd
+     write(u) size(qq, 1), size(qq, 2), size(qq, 3), qq
+
+     close(u)
+   end if
+end subroutine get_multiints
 
-pure subroutine get_grad_multiint(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj, &
+subroutine get_grad_multiint(icao,jcao,naoi,naoj,ishtyp,jshtyp,ri,rj, &
       &                           intcut,nprim,primcount,alp,cont,sdq,sdqg)
    integer, intent(in)  :: icao
    integer, intent(in)  :: jcao
diff --git a/src/meson.build b/src/meson.build
index ced9a9d..12ddc1d 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -158,4 +158,5 @@ srcs += files(
   'wrmo.f90',
   'xhelp.f90',
   'zmatpr.f90',
+  'utils.f90',
 )
diff --git a/src/scc_core.f90 b/src/scc_core.f90
index 5b29581..65fb968 100644
--- a/src/scc_core.f90
+++ b/src/scc_core.f90
@@ -29,6 +29,7 @@ module xtb_scc_core
    use xtb_xtb_dispersion
    use xtb_xtb_multipole
    use xtb_broyden
+   use utils
    implicit none
    private
 
@@ -606,7 +607,7 @@ end subroutine scc
 
 
 !> H0 off-diag scaling
-subroutine h0scal(hData,il,jl,izp,jzp,valaoi,valaoj,km)
+subroutine gh0scal(hData,il,jl,izp,jzp,valaoi,valaoj,km)
   !$acc routine seq
    type(THamiltonianData), intent(in) :: hData
    integer, intent(in)  :: il
@@ -642,8 +643,38 @@ subroutine h0scal(hData,il,jl,izp,jzp,valaoi,valaoj,km)
    endif
 
 
-end subroutine h0scal
+end subroutine gh0scal
 
+subroutine h0scal(hData,il,jl,izp,jzp,valaoi,valaoj,km)
+  !$acc routine seq
+   type(THamiltonianData), intent(in) :: hData
+   integer, intent(in)  :: il
+   integer, intent(in)  :: jl
+   integer, intent(in)  :: izp
+   integer, intent(in)  :: jzp
+   logical, intent(in)  :: valaoi
+   logical, intent(in)  :: valaoj
+   real(wp),intent(out) :: km
+
+   logical :: exists
+   integer :: u
+   character(len=200) :: path
+
+   exists = testfile_path('h0scal', path)
+   if (.not.exists) then
+     open(newunit=u, file=trim(path), form='unformatted', access='stream')
+     write(u) il, jl
+     write(u) izp, jzp
+     write(u) valaoi, valaoj
+   end if
+
+   call gh0scal(hData,il,jl,izp,jzp,valaoi,valaoj,km)
+
+   if (.not.exists) then
+     write(u) km
+     close(u)
+   end if
+end subroutine h0scal
 
 !! ========================================================================
 !  total energy for GFN1
diff --git a/src/utils.f90 b/src/utils.f90
new file mode 100644
index 0000000..aaf4ae3
--- /dev/null
+++ b/src/utils.f90
@@ -0,0 +1,76 @@
+module utils
+  implicit none
+  contains
+
+  subroutine random_uuid(uuid)
+      character(len=*), intent(out) :: uuid
+      character(len=16) :: hexchars
+      integer :: i, n
+      real :: r(1)
+      character(len=1) :: c
+
+      hexchars = '0123456789abcdef'
+      uuid = ''
+      do i = 1, 36
+          if (i == 9 .or. i == 14 .or. i == 19 .or. i == 24) then
+              uuid(i:i) = '-'
+          else
+              call random_number(r)
+              n = 1 + int(r(1) * 16.0)
+              uuid(i:i) = hexchars(n:n)
+          end if
+      end do
+  end subroutine
+
+  subroutine create_directory(dir_name)
+     character(len=*), intent(in) :: dir_name
+     character(len=255) :: command
+
+     ! Construct the command to create the directory
+     write(command, '("mkdir -p ", A)') trim(adjustl(dir_name))
+
+     ! Execute the command
+     call system(command)
+  end subroutine create_directory
+
+  logical function testfile_path(fn_name, path)
+    implicit none
+    character(len=*), intent(in)  :: fn_name
+    character(len=*), intent(out) :: path
+
+    character(len=36) :: uuid
+    character(len=100) :: filename, dir
+
+    integer, parameter :: max_cached = 100
+    character(len=100), save :: cached_dirs(max_cached) = ''
+    integer :: i, slot
+
+    dir = 'calls/' // trim(fn_name) // '/'
+    slot = -1
+
+    ! Search for fn_name in cache
+    do i = 1, max_cached
+      if (trim(cached_dirs(i)) == trim(dir)) then
+        testfile_path = .true.
+        return
+      elseif (cached_dirs(i) == '') then
+        slot = i
+      end if
+    end do
+
+    ! Not in cache, do the check
+    inquire(file=trim(dir)//'.', exist=testfile_path)
+
+    if (.not. testfile_path) then
+      call create_directory(trim(dir))
+
+      call random_seed()
+      call random_uuid(uuid)
+      write(filename, '(A,A)') 'args_', uuid
+      write(path, '(A,A,A)') trim(dir), trim(filename), ".bin"
+    endif
+
+    cached_dirs(slot) = dir
+  end function testfile_path
+
+end module utils
diff --git a/src/xtb/hamiltonian.f90 b/src/xtb/hamiltonian.f90
index 59ca64c..29114bb 100644
--- a/src/xtb/hamiltonian.f90
+++ b/src/xtb/hamiltonian.f90
@@ -143,7 +143,7 @@ end subroutine getSelfEnergy2D
 
 !> Computes the dipole and quadrupole integrals and performs screening to
 !  determine, which contribute to potential
-subroutine build_SDQH0(nShell, hData, nat, at, nbf, nao, xyz, trans, selfEnergy, &
+subroutine gbuild_SDQH0(nShell, hData, nat, at, nbf, nao, xyz, trans, selfEnergy, &
       & intcut, caoshell, saoshell, nprim, primcount, alp, cont, &
       & sint, dpint, qpint, H0, H0_noovlp)
    implicit none
@@ -368,6 +368,96 @@ subroutine build_SDQH0(nShell, hData, nat, at, nbf, nao, xyz, trans, selfEnergy,
       end do
    end do
 
+end subroutine gbuild_SDQH0
+
+subroutine build_SDQH0(nShell, hData, nat, at, nbf, nao, xyz, trans, selfEnergy, &
+      & intcut, caoshell, saoshell, nprim, primcount, alp, cont, &
+      & sint, dpint, qpint, H0, H0_noovlp)
+   implicit none
+   integer, intent(in) :: nShell(:)
+   type(THamiltonianData), intent(in) :: hData
+   !> # of atoms
+   integer, intent(in)  :: nat
+   !> # of spherical AOs (SAOs)
+   integer, intent(in)  :: nao
+   !> # of Cartesian AOs (CAOs)
+   integer, intent(in)  :: nbf
+   integer, intent(in)  :: at(nat)
+   !> Cartesian coordinates
+   real(wp),intent(in)  :: xyz(3,nat)
+   real(wp),intent(in)    :: trans(:, :)
+   real(wp), intent(in) :: selfEnergy(:, :)
+   !> Integral cutoff according to prefactor from Gaussian product theorem
+   real(wp),intent(in)  :: intcut
+   !> Map shell of atom to index in CAO space (lowest Cart. component is taken)
+   integer, intent(in)  :: caoshell(:,:)
+   !> Map shell of atom to index in SAO space (lowest m_l component is taken)
+   integer, intent(in)  :: saoshell(:,:)
+   integer, intent(in)  :: nprim(:)
+   !> Index of first primitive (over entire system) of given CAO
+   integer, intent(in)  :: primcount(:)
+   real(wp),intent(in)  :: alp(:)
+   real(wp),intent(in)  :: cont(:)
+   !> Overlap integral matrix
+   real(wp),intent(out) :: sint(nao,nao)
+   !> Dipole integral matrix
+   real(wp),intent(out) :: dpint(3,nao,nao)
+   !> Quadrupole integral matrix
+   real(wp),intent(out) :: qpint(6,nao,nao)
+   !> Core Hamiltonian
+   real(wp),intent(out) :: H0(:)
+   !> Core Hamiltonian without overlap contribution
+   real(wp),intent(out) :: H0_noovlp(:)
+
+
+   integer i,j,k,l,m,ii,jj,ll,mm,kk,ki,kj,kl,mi,mj,ij
+   real(wp) tmp1,tmp2,tmp3,tmp4,step,step2
+   real(wp) dx,dy,dz,s00r,s00l,s00,alpj
+   real(wp) skj,r1,r2,tt,t1,t2,t3,t4,thr2,f,ci,cc,cj,alpi,rab2,ab,est
+
+   real(wp)  ra(3),rb(3),f1,f2,point(3)
+   real(wp) dtmp(3),qtmp(6),ss(6,6),dd(3,6,6),qq(6,6,6),tmp(6,6)
+   integer ip,jp,iat,jat,izp,jzp,ish,jsh,icao,jcao,iao,jao,jshmax
+   integer ishtyp,jshtyp,iptyp,jptyp,naoi,naoj,mli,mlj,iprim,jprim
+   integer :: il, jl, itr
+   real(wp) :: zi, zj, zetaij, km, hii, hjj, hav, shpoly
+   integer itt(0:3)
+   parameter(itt  =(/0,1,4,10/))
+   real(wp) :: saw(10)
+
+   logical :: exists
+   integer :: u
+   character(len=200) :: path
+
+   exists = testfile_path('build_SDQH0', path)
+   if (.not.exists) then
+     open(newunit=u, file=trim(path), form='unformatted', access='stream')
+     write(u) nat
+     write(u) size(at), at
+     write(u) nbf
+     write(u) nao
+     write(u) size(xyz, 1), size(xyz, 2), xyz
+     write(u) size(trans, 1), size(trans, 2), trans
+     write(u) size(selfEnergy, 1), size(selfEnergy, 2), selfEnergy
+     write(u) intcut
+     write(u) size(caoshell, 1), size(caoshell, 2), caoshell
+     write(u) size(saoshell, 1), size(saoshell, 2), saoshell
+     write(u) size(nprim), nprim
+     write(u) size(primcount), primcount
+     write(u) size(alp), alp
+     write(u) size(cont), cont
+   end if
+
+   call gbuild_SDQH0(nShell, hData, nat, at, nbf, nao, xyz, trans, selfEnergy, intcut, caoshell, saoshell, nprim, primcount, alp, cont, sint, dpint, qpint, H0, H0_noovlp)
+
+   if (.not.exists) then
+     write(u) size(sint, 1), size(sint, 2), sint
+     write(u) size(dpint, 1), size(dpint, 2), size(dpint, 3), dpint
+     write(u) size(qpint, 1), size(qpint, 2), size(qpint, 3), qpint
+     write(u) size(H0), H0
+     write(u) size(H0_noovlp), H0_noovlp
+     close(u)
+   end if
 end subroutine build_SDQH0
 
 
